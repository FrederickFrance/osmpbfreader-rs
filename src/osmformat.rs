// This file is generated. Do not edit

#![allow(dead_code)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(unused_imports)]


#[deriving(Clone,PartialEq,Default,Show)]
pub struct HeaderBlock {
    bbox: ::protobuf::SingularPtrField<HeaderBBox>,
    required_features: ::protobuf::RepeatedField<::std::string::String>,
    optional_features: ::protobuf::RepeatedField<::std::string::String>,
    writingprogram: ::protobuf::SingularField<::std::string::String>,
    source: ::protobuf::SingularField<::std::string::String>,
    osmosis_replication_timestamp: ::std::option::Option<i64>,
    osmosis_replication_sequence_number: ::std::option::Option<i64>,
    osmosis_replication_base_url: ::protobuf::SingularField<::std::string::String>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> HeaderBlock {
    pub fn new() -> HeaderBlock {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static HeaderBlock {
        static mut instance: ::protobuf::lazy::Lazy<HeaderBlock> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const HeaderBlock };
        unsafe {
            instance.get(|| {
                HeaderBlock {
                    bbox: ::protobuf::SingularPtrField::none(),
                    required_features: ::protobuf::RepeatedField::new(),
                    optional_features: ::protobuf::RepeatedField::new(),
                    writingprogram: ::protobuf::SingularField::none(),
                    source: ::protobuf::SingularField::none(),
                    osmosis_replication_timestamp: ::std::option::None,
                    osmosis_replication_sequence_number: ::std::option::None,
                    osmosis_replication_base_url: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    // optional .OSMPBF.HeaderBBox bbox = 1;

    pub fn clear_bbox(&mut self) {
        self.bbox.clear();
    }

    pub fn has_bbox(&self) -> bool {
        self.bbox.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bbox(&mut self, v: HeaderBBox) {
        self.bbox = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bbox(&'a mut self) -> &'a mut HeaderBBox {
        if self.bbox.is_none() {
            self.bbox.set_default();
        };
        self.bbox.as_mut().unwrap()
    }

    pub fn get_bbox(&'a self) -> &'a HeaderBBox {
        self.bbox.as_ref().unwrap_or_else(|| HeaderBBox::default_instance())
    }

    // repeated string required_features = 4;

    pub fn clear_required_features(&mut self) {
        self.required_features.clear();
    }

    // Param is passed by value, moved
    pub fn set_required_features(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.required_features = v;
    }

    // Mutable pointer to the field.
    pub fn mut_required_features(&'a mut self) -> &'a mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.required_features
    }

    pub fn get_required_features(&'a self) -> &'a [::std::string::String] {
        self.required_features.as_slice()
    }

    // repeated string optional_features = 5;

    pub fn clear_optional_features(&mut self) {
        self.optional_features.clear();
    }

    // Param is passed by value, moved
    pub fn set_optional_features(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.optional_features = v;
    }

    // Mutable pointer to the field.
    pub fn mut_optional_features(&'a mut self) -> &'a mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.optional_features
    }

    pub fn get_optional_features(&'a self) -> &'a [::std::string::String] {
        self.optional_features.as_slice()
    }

    // optional string writingprogram = 16;

    pub fn clear_writingprogram(&mut self) {
        self.writingprogram.clear();
    }

    pub fn has_writingprogram(&self) -> bool {
        self.writingprogram.is_some()
    }

    // Param is passed by value, moved
    pub fn set_writingprogram(&mut self, v: ::std::string::String) {
        self.writingprogram = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_writingprogram(&'a mut self) -> &'a mut ::std::string::String {
        if self.writingprogram.is_none() {
            self.writingprogram.set_default();
        };
        self.writingprogram.as_mut().unwrap()
    }

    pub fn get_writingprogram(&'a self) -> &'a str {
        match self.writingprogram.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }

    // optional string source = 17;

    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: ::std::string::String) {
        self.source = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&'a mut self) -> &'a mut ::std::string::String {
        if self.source.is_none() {
            self.source.set_default();
        };
        self.source.as_mut().unwrap()
    }

    pub fn get_source(&'a self) -> &'a str {
        match self.source.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }

    // optional int64 osmosis_replication_timestamp = 32;

    pub fn clear_osmosis_replication_timestamp(&mut self) {
        self.osmosis_replication_timestamp = None;
    }

    pub fn has_osmosis_replication_timestamp(&self) -> bool {
        self.osmosis_replication_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_osmosis_replication_timestamp(&mut self, v: i64) {
        self.osmosis_replication_timestamp = Some(v);
    }

    pub fn get_osmosis_replication_timestamp(&self) -> i64 {
        self.osmosis_replication_timestamp.unwrap_or(0)
    }

    // optional int64 osmosis_replication_sequence_number = 33;

    pub fn clear_osmosis_replication_sequence_number(&mut self) {
        self.osmosis_replication_sequence_number = None;
    }

    pub fn has_osmosis_replication_sequence_number(&self) -> bool {
        self.osmosis_replication_sequence_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_osmosis_replication_sequence_number(&mut self, v: i64) {
        self.osmosis_replication_sequence_number = Some(v);
    }

    pub fn get_osmosis_replication_sequence_number(&self) -> i64 {
        self.osmosis_replication_sequence_number.unwrap_or(0)
    }

    // optional string osmosis_replication_base_url = 34;

    pub fn clear_osmosis_replication_base_url(&mut self) {
        self.osmosis_replication_base_url.clear();
    }

    pub fn has_osmosis_replication_base_url(&self) -> bool {
        self.osmosis_replication_base_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_osmosis_replication_base_url(&mut self, v: ::std::string::String) {
        self.osmosis_replication_base_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_osmosis_replication_base_url(&'a mut self) -> &'a mut ::std::string::String {
        if self.osmosis_replication_base_url.is_none() {
            self.osmosis_replication_base_url.set_default();
        };
        self.osmosis_replication_base_url.as_mut().unwrap()
    }

    pub fn get_osmosis_replication_base_url(&'a self) -> &'a str {
        match self.osmosis_replication_base_url.as_ref() {
            Some(ref v) => v.as_slice(),
            None => "",
        }
    }
}

impl ::protobuf::Message for HeaderBlock {
    fn new() -> HeaderBlock {
        HeaderBlock::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.bbox.set_default();
                    try!(is.merge_message(tmp))
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.required_features.push_default();
                    try!(is.read_string_into(tmp))
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.optional_features.push_default();
                    try!(is.read_string_into(tmp))
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.writingprogram.set_default();
                    try!(is.read_string_into(tmp))
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.source.set_default();
                    try!(is.read_string_into(tmp))
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int64());
                    self.osmosis_replication_timestamp = Some(tmp);
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int64());
                    self.osmosis_replication_sequence_number = Some(tmp);
                },
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.osmosis_replication_base_url.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Ok(())
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut ::std::vec::Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.bbox.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.required_features.iter() {
            my_size += ::protobuf::rt::string_size(4, value.as_slice());
        };
        for value in self.optional_features.iter() {
            my_size += ::protobuf::rt::string_size(5, value.as_slice());
        };
        for value in self.writingprogram.iter() {
            my_size += ::protobuf::rt::string_size(16, value.as_slice());
        };
        for value in self.source.iter() {
            my_size += ::protobuf::rt::string_size(17, value.as_slice());
        };
        for value in self.osmosis_replication_timestamp.iter() {
            my_size += ::protobuf::rt::value_size(32, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.osmosis_replication_sequence_number.iter() {
            my_size += ::protobuf::rt::value_size(33, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.osmosis_replication_base_url.iter() {
            my_size += ::protobuf::rt::string_size(34, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        sizes[pos] = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) -> ::protobuf::ProtobufResult<()> {
        use protobuf::{Message};
        match self.bbox.as_ref() {
            Some(ref v) => {
                try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
                try!(os.write_raw_varint32(sizes[*sizes_pos]));
                *sizes_pos += 1;
                try!(v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos));
            },
            None => {},
        };
        for v in self.required_features.iter() {
            try!(os.write_string(4, v.as_slice()));
        };
        for v in self.optional_features.iter() {
            try!(os.write_string(5, v.as_slice()));
        };
        match self.writingprogram.as_ref() {
            Some(ref v) => {
                try!(os.write_string(16, v.as_slice()));
            },
            None => {},
        };
        match self.source.as_ref() {
            Some(ref v) => {
                try!(os.write_string(17, v.as_slice()));
            },
            None => {},
        };
        match self.osmosis_replication_timestamp {
            Some(ref v) => {
                try!(os.write_int64(32, *v));
            },
            None => {},
        };
        match self.osmosis_replication_sequence_number {
            Some(ref v) => {
                try!(os.write_int64(33, *v));
            },
            None => {},
        };
        match self.osmosis_replication_base_url.as_ref() {
            Some(ref v) => {
                try!(os.write_string(34, v.as_slice()));
            },
            None => {},
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Ok(())
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<HeaderBlock>()
    }
}

impl ::protobuf::Clear for HeaderBlock {
    fn clear(&mut self) {
        self.clear_bbox();
        self.clear_required_features();
        self.clear_optional_features();
        self.clear_writingprogram();
        self.clear_source();
        self.clear_osmosis_replication_timestamp();
        self.clear_osmosis_replication_sequence_number();
        self.clear_osmosis_replication_base_url();
        self.unknown_fields.clear();
    }
}

#[deriving(Clone,PartialEq,Default,Show)]
pub struct HeaderBBox {
    left: ::std::option::Option<i64>,
    right: ::std::option::Option<i64>,
    top: ::std::option::Option<i64>,
    bottom: ::std::option::Option<i64>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> HeaderBBox {
    pub fn new() -> HeaderBBox {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static HeaderBBox {
        static mut instance: ::protobuf::lazy::Lazy<HeaderBBox> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const HeaderBBox };
        unsafe {
            instance.get(|| {
                HeaderBBox {
                    left: ::std::option::None,
                    right: ::std::option::None,
                    top: ::std::option::None,
                    bottom: ::std::option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    // required sint64 left = 1;

    pub fn clear_left(&mut self) {
        self.left = None;
    }

    pub fn has_left(&self) -> bool {
        self.left.is_some()
    }

    // Param is passed by value, moved
    pub fn set_left(&mut self, v: i64) {
        self.left = Some(v);
    }

    pub fn get_left(&self) -> i64 {
        self.left.unwrap_or(0)
    }

    // required sint64 right = 2;

    pub fn clear_right(&mut self) {
        self.right = None;
    }

    pub fn has_right(&self) -> bool {
        self.right.is_some()
    }

    // Param is passed by value, moved
    pub fn set_right(&mut self, v: i64) {
        self.right = Some(v);
    }

    pub fn get_right(&self) -> i64 {
        self.right.unwrap_or(0)
    }

    // required sint64 top = 3;

    pub fn clear_top(&mut self) {
        self.top = None;
    }

    pub fn has_top(&self) -> bool {
        self.top.is_some()
    }

    // Param is passed by value, moved
    pub fn set_top(&mut self, v: i64) {
        self.top = Some(v);
    }

    pub fn get_top(&self) -> i64 {
        self.top.unwrap_or(0)
    }

    // required sint64 bottom = 4;

    pub fn clear_bottom(&mut self) {
        self.bottom = None;
    }

    pub fn has_bottom(&self) -> bool {
        self.bottom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bottom(&mut self, v: i64) {
        self.bottom = Some(v);
    }

    pub fn get_bottom(&self) -> i64 {
        self.bottom.unwrap_or(0)
    }
}

impl ::protobuf::Message for HeaderBBox {
    fn new() -> HeaderBBox {
        HeaderBBox::new()
    }

    fn is_initialized(&self) -> bool {
        if self.left.is_none() {
            return false;
        };
        if self.right.is_none() {
            return false;
        };
        if self.top.is_none() {
            return false;
        };
        if self.bottom.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_sint64());
                    self.left = Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_sint64());
                    self.right = Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_sint64());
                    self.top = Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_sint64());
                    self.bottom = Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Ok(())
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut ::std::vec::Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.left.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.right.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.top.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.bottom.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        sizes[pos] = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variables)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) -> ::protobuf::ProtobufResult<()> {
        use protobuf::{Message};
        match self.left {
            Some(ref v) => {
                try!(os.write_sint64(1, *v));
            },
            None => {},
        };
        match self.right {
            Some(ref v) => {
                try!(os.write_sint64(2, *v));
            },
            None => {},
        };
        match self.top {
            Some(ref v) => {
                try!(os.write_sint64(3, *v));
            },
            None => {},
        };
        match self.bottom {
            Some(ref v) => {
                try!(os.write_sint64(4, *v));
            },
            None => {},
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Ok(())
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<HeaderBBox>()
    }
}

impl ::protobuf::Clear for HeaderBBox {
    fn clear(&mut self) {
        self.clear_left();
        self.clear_right();
        self.clear_top();
        self.clear_bottom();
        self.unknown_fields.clear();
    }
}

#[deriving(Clone,PartialEq,Default,Show)]
pub struct PrimitiveBlock {
    stringtable: ::protobuf::SingularPtrField<StringTable>,
    primitivegroup: ::protobuf::RepeatedField<PrimitiveGroup>,
    granularity: ::std::option::Option<i32>,
    lat_offset: ::std::option::Option<i64>,
    lon_offset: ::std::option::Option<i64>,
    date_granularity: ::std::option::Option<i32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> PrimitiveBlock {
    pub fn new() -> PrimitiveBlock {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PrimitiveBlock {
        static mut instance: ::protobuf::lazy::Lazy<PrimitiveBlock> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const PrimitiveBlock };
        unsafe {
            instance.get(|| {
                PrimitiveBlock {
                    stringtable: ::protobuf::SingularPtrField::none(),
                    primitivegroup: ::protobuf::RepeatedField::new(),
                    granularity: ::std::option::None,
                    lat_offset: ::std::option::None,
                    lon_offset: ::std::option::None,
                    date_granularity: ::std::option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    // required .OSMPBF.StringTable stringtable = 1;

    pub fn clear_stringtable(&mut self) {
        self.stringtable.clear();
    }

    pub fn has_stringtable(&self) -> bool {
        self.stringtable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stringtable(&mut self, v: StringTable) {
        self.stringtable = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stringtable(&'a mut self) -> &'a mut StringTable {
        if self.stringtable.is_none() {
            self.stringtable.set_default();
        };
        self.stringtable.as_mut().unwrap()
    }

    pub fn get_stringtable(&'a self) -> &'a StringTable {
        self.stringtable.as_ref().unwrap_or_else(|| StringTable::default_instance())
    }

    // repeated .OSMPBF.PrimitiveGroup primitivegroup = 2;

    pub fn clear_primitivegroup(&mut self) {
        self.primitivegroup.clear();
    }

    // Param is passed by value, moved
    pub fn set_primitivegroup(&mut self, v: ::protobuf::RepeatedField<PrimitiveGroup>) {
        self.primitivegroup = v;
    }

    // Mutable pointer to the field.
    pub fn mut_primitivegroup(&'a mut self) -> &'a mut ::protobuf::RepeatedField<PrimitiveGroup> {
        &mut self.primitivegroup
    }

    pub fn get_primitivegroup(&'a self) -> &'a [PrimitiveGroup] {
        self.primitivegroup.as_slice()
    }

    // optional int32 granularity = 17;

    pub fn clear_granularity(&mut self) {
        self.granularity = None;
    }

    pub fn has_granularity(&self) -> bool {
        self.granularity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_granularity(&mut self, v: i32) {
        self.granularity = Some(v);
    }

    pub fn get_granularity(&self) -> i32 {
        self.granularity.unwrap_or(100i32)
    }

    // optional int64 lat_offset = 19;

    pub fn clear_lat_offset(&mut self) {
        self.lat_offset = None;
    }

    pub fn has_lat_offset(&self) -> bool {
        self.lat_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lat_offset(&mut self, v: i64) {
        self.lat_offset = Some(v);
    }

    pub fn get_lat_offset(&self) -> i64 {
        self.lat_offset.unwrap_or(0i64)
    }

    // optional int64 lon_offset = 20;

    pub fn clear_lon_offset(&mut self) {
        self.lon_offset = None;
    }

    pub fn has_lon_offset(&self) -> bool {
        self.lon_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lon_offset(&mut self, v: i64) {
        self.lon_offset = Some(v);
    }

    pub fn get_lon_offset(&self) -> i64 {
        self.lon_offset.unwrap_or(0i64)
    }

    // optional int32 date_granularity = 18;

    pub fn clear_date_granularity(&mut self) {
        self.date_granularity = None;
    }

    pub fn has_date_granularity(&self) -> bool {
        self.date_granularity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_date_granularity(&mut self, v: i32) {
        self.date_granularity = Some(v);
    }

    pub fn get_date_granularity(&self) -> i32 {
        self.date_granularity.unwrap_or(1000i32)
    }
}

impl ::protobuf::Message for PrimitiveBlock {
    fn new() -> PrimitiveBlock {
        PrimitiveBlock::new()
    }

    fn is_initialized(&self) -> bool {
        if self.stringtable.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.stringtable.set_default();
                    try!(is.merge_message(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.primitivegroup.push_default();
                    try!(is.merge_message(tmp))
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int32());
                    self.granularity = Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int64());
                    self.lat_offset = Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int64());
                    self.lon_offset = Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int32());
                    self.date_granularity = Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Ok(())
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut ::std::vec::Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.stringtable.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.primitivegroup.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.granularity.iter() {
            my_size += ::protobuf::rt::value_size(17, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.lat_offset.iter() {
            my_size += ::protobuf::rt::value_size(19, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.lon_offset.iter() {
            my_size += ::protobuf::rt::value_size(20, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.date_granularity.iter() {
            my_size += ::protobuf::rt::value_size(18, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        sizes[pos] = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) -> ::protobuf::ProtobufResult<()> {
        use protobuf::{Message};
        match self.stringtable.as_ref() {
            Some(ref v) => {
                try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
                try!(os.write_raw_varint32(sizes[*sizes_pos]));
                *sizes_pos += 1;
                try!(v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos));
            },
            None => {},
        };
        for v in self.primitivegroup.iter() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(sizes[*sizes_pos]));
            *sizes_pos += 1;
            try!(v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos));
        };
        match self.granularity {
            Some(ref v) => {
                try!(os.write_int32(17, *v));
            },
            None => {},
        };
        match self.lat_offset {
            Some(ref v) => {
                try!(os.write_int64(19, *v));
            },
            None => {},
        };
        match self.lon_offset {
            Some(ref v) => {
                try!(os.write_int64(20, *v));
            },
            None => {},
        };
        match self.date_granularity {
            Some(ref v) => {
                try!(os.write_int32(18, *v));
            },
            None => {},
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Ok(())
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<PrimitiveBlock>()
    }
}

impl ::protobuf::Clear for PrimitiveBlock {
    fn clear(&mut self) {
        self.clear_stringtable();
        self.clear_primitivegroup();
        self.clear_granularity();
        self.clear_lat_offset();
        self.clear_lon_offset();
        self.clear_date_granularity();
        self.unknown_fields.clear();
    }
}

#[deriving(Clone,PartialEq,Default,Show)]
pub struct PrimitiveGroup {
    nodes: ::protobuf::RepeatedField<Node>,
    dense: ::protobuf::SingularPtrField<DenseNodes>,
    ways: ::protobuf::RepeatedField<Way>,
    relations: ::protobuf::RepeatedField<Relation>,
    changesets: ::protobuf::RepeatedField<ChangeSet>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> PrimitiveGroup {
    pub fn new() -> PrimitiveGroup {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PrimitiveGroup {
        static mut instance: ::protobuf::lazy::Lazy<PrimitiveGroup> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const PrimitiveGroup };
        unsafe {
            instance.get(|| {
                PrimitiveGroup {
                    nodes: ::protobuf::RepeatedField::new(),
                    dense: ::protobuf::SingularPtrField::none(),
                    ways: ::protobuf::RepeatedField::new(),
                    relations: ::protobuf::RepeatedField::new(),
                    changesets: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    // repeated .OSMPBF.Node nodes = 1;

    pub fn clear_nodes(&mut self) {
        self.nodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodes(&mut self, v: ::protobuf::RepeatedField<Node>) {
        self.nodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nodes(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Node> {
        &mut self.nodes
    }

    pub fn get_nodes(&'a self) -> &'a [Node] {
        self.nodes.as_slice()
    }

    // optional .OSMPBF.DenseNodes dense = 2;

    pub fn clear_dense(&mut self) {
        self.dense.clear();
    }

    pub fn has_dense(&self) -> bool {
        self.dense.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dense(&mut self, v: DenseNodes) {
        self.dense = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dense(&'a mut self) -> &'a mut DenseNodes {
        if self.dense.is_none() {
            self.dense.set_default();
        };
        self.dense.as_mut().unwrap()
    }

    pub fn get_dense(&'a self) -> &'a DenseNodes {
        self.dense.as_ref().unwrap_or_else(|| DenseNodes::default_instance())
    }

    // repeated .OSMPBF.Way ways = 3;

    pub fn clear_ways(&mut self) {
        self.ways.clear();
    }

    // Param is passed by value, moved
    pub fn set_ways(&mut self, v: ::protobuf::RepeatedField<Way>) {
        self.ways = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ways(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Way> {
        &mut self.ways
    }

    pub fn get_ways(&'a self) -> &'a [Way] {
        self.ways.as_slice()
    }

    // repeated .OSMPBF.Relation relations = 4;

    pub fn clear_relations(&mut self) {
        self.relations.clear();
    }

    // Param is passed by value, moved
    pub fn set_relations(&mut self, v: ::protobuf::RepeatedField<Relation>) {
        self.relations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_relations(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Relation> {
        &mut self.relations
    }

    pub fn get_relations(&'a self) -> &'a [Relation] {
        self.relations.as_slice()
    }

    // repeated .OSMPBF.ChangeSet changesets = 5;

    pub fn clear_changesets(&mut self) {
        self.changesets.clear();
    }

    // Param is passed by value, moved
    pub fn set_changesets(&mut self, v: ::protobuf::RepeatedField<ChangeSet>) {
        self.changesets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_changesets(&'a mut self) -> &'a mut ::protobuf::RepeatedField<ChangeSet> {
        &mut self.changesets
    }

    pub fn get_changesets(&'a self) -> &'a [ChangeSet] {
        self.changesets.as_slice()
    }
}

impl ::protobuf::Message for PrimitiveGroup {
    fn new() -> PrimitiveGroup {
        PrimitiveGroup::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.nodes.push_default();
                    try!(is.merge_message(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.dense.set_default();
                    try!(is.merge_message(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.ways.push_default();
                    try!(is.merge_message(tmp))
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.relations.push_default();
                    try!(is.merge_message(tmp))
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.changesets.push_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Ok(())
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut ::std::vec::Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.nodes.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.dense.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.ways.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.relations.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.changesets.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        sizes[pos] = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) -> ::protobuf::ProtobufResult<()> {
        use protobuf::{Message};
        for v in self.nodes.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(sizes[*sizes_pos]));
            *sizes_pos += 1;
            try!(v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos));
        };
        match self.dense.as_ref() {
            Some(ref v) => {
                try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
                try!(os.write_raw_varint32(sizes[*sizes_pos]));
                *sizes_pos += 1;
                try!(v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos));
            },
            None => {},
        };
        for v in self.ways.iter() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(sizes[*sizes_pos]));
            *sizes_pos += 1;
            try!(v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos));
        };
        for v in self.relations.iter() {
            try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(sizes[*sizes_pos]));
            *sizes_pos += 1;
            try!(v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos));
        };
        for v in self.changesets.iter() {
            try!(os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(sizes[*sizes_pos]));
            *sizes_pos += 1;
            try!(v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Ok(())
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<PrimitiveGroup>()
    }
}

impl ::protobuf::Clear for PrimitiveGroup {
    fn clear(&mut self) {
        self.clear_nodes();
        self.clear_dense();
        self.clear_ways();
        self.clear_relations();
        self.clear_changesets();
        self.unknown_fields.clear();
    }
}

#[deriving(Clone,PartialEq,Default,Show)]
pub struct StringTable {
    s: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> StringTable {
    pub fn new() -> StringTable {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static StringTable {
        static mut instance: ::protobuf::lazy::Lazy<StringTable> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const StringTable };
        unsafe {
            instance.get(|| {
                StringTable {
                    s: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    // repeated bytes s = 1;

    pub fn clear_s(&mut self) {
        self.s.clear();
    }

    // Param is passed by value, moved
    pub fn set_s(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.s = v;
    }

    // Mutable pointer to the field.
    pub fn mut_s(&'a mut self) -> &'a mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.s
    }

    pub fn get_s(&'a self) -> &'a [::std::vec::Vec<u8>] {
        self.s.as_slice()
    }
}

impl ::protobuf::Message for StringTable {
    fn new() -> StringTable {
        StringTable::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.s.push_default();
                    try!(is.read_bytes_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Ok(())
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut ::std::vec::Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.s.iter() {
            my_size += ::protobuf::rt::bytes_size(1, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        sizes[pos] = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variables)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) -> ::protobuf::ProtobufResult<()> {
        use protobuf::{Message};
        for v in self.s.iter() {
            try!(os.write_bytes(1, v.as_slice()));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Ok(())
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<StringTable>()
    }
}

impl ::protobuf::Clear for StringTable {
    fn clear(&mut self) {
        self.clear_s();
        self.unknown_fields.clear();
    }
}

#[deriving(Clone,PartialEq,Default,Show)]
pub struct Info {
    version: ::std::option::Option<i32>,
    timestamp: ::std::option::Option<i64>,
    changeset: ::std::option::Option<i64>,
    uid: ::std::option::Option<i32>,
    user_sid: ::std::option::Option<u32>,
    visible: ::std::option::Option<bool>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> Info {
    pub fn new() -> Info {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Info {
        static mut instance: ::protobuf::lazy::Lazy<Info> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const Info };
        unsafe {
            instance.get(|| {
                Info {
                    version: ::std::option::None,
                    timestamp: ::std::option::None,
                    changeset: ::std::option::None,
                    uid: ::std::option::None,
                    user_sid: ::std::option::None,
                    visible: ::std::option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    // optional int32 version = 1;

    pub fn clear_version(&mut self) {
        self.version = None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i32) {
        self.version = Some(v);
    }

    pub fn get_version(&self) -> i32 {
        self.version.unwrap_or(-1i32)
    }

    // optional int64 timestamp = 2;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = Some(v);
    }

    pub fn get_timestamp(&self) -> i64 {
        self.timestamp.unwrap_or(0)
    }

    // optional int64 changeset = 3;

    pub fn clear_changeset(&mut self) {
        self.changeset = None;
    }

    pub fn has_changeset(&self) -> bool {
        self.changeset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_changeset(&mut self, v: i64) {
        self.changeset = Some(v);
    }

    pub fn get_changeset(&self) -> i64 {
        self.changeset.unwrap_or(0)
    }

    // optional int32 uid = 4;

    pub fn clear_uid(&mut self) {
        self.uid = None;
    }

    pub fn has_uid(&self) -> bool {
        self.uid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: i32) {
        self.uid = Some(v);
    }

    pub fn get_uid(&self) -> i32 {
        self.uid.unwrap_or(0)
    }

    // optional uint32 user_sid = 5;

    pub fn clear_user_sid(&mut self) {
        self.user_sid = None;
    }

    pub fn has_user_sid(&self) -> bool {
        self.user_sid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_sid(&mut self, v: u32) {
        self.user_sid = Some(v);
    }

    pub fn get_user_sid(&self) -> u32 {
        self.user_sid.unwrap_or(0)
    }

    // optional bool visible = 6;

    pub fn clear_visible(&mut self) {
        self.visible = None;
    }

    pub fn has_visible(&self) -> bool {
        self.visible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visible(&mut self, v: bool) {
        self.visible = Some(v);
    }

    pub fn get_visible(&self) -> bool {
        self.visible.unwrap_or(false)
    }
}

impl ::protobuf::Message for Info {
    fn new() -> Info {
        Info::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int32());
                    self.version = Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int64());
                    self.timestamp = Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int64());
                    self.changeset = Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int32());
                    self.uid = Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint32());
                    self.user_sid = Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.visible = Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Ok(())
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut ::std::vec::Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.version.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.timestamp.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.changeset.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.uid.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.user_sid.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.visible.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        sizes[pos] = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variables)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) -> ::protobuf::ProtobufResult<()> {
        use protobuf::{Message};
        match self.version {
            Some(ref v) => {
                try!(os.write_int32(1, *v));
            },
            None => {},
        };
        match self.timestamp {
            Some(ref v) => {
                try!(os.write_int64(2, *v));
            },
            None => {},
        };
        match self.changeset {
            Some(ref v) => {
                try!(os.write_int64(3, *v));
            },
            None => {},
        };
        match self.uid {
            Some(ref v) => {
                try!(os.write_int32(4, *v));
            },
            None => {},
        };
        match self.user_sid {
            Some(ref v) => {
                try!(os.write_uint32(5, *v));
            },
            None => {},
        };
        match self.visible {
            Some(ref v) => {
                try!(os.write_bool(6, *v));
            },
            None => {},
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Ok(())
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<Info>()
    }
}

impl ::protobuf::Clear for Info {
    fn clear(&mut self) {
        self.clear_version();
        self.clear_timestamp();
        self.clear_changeset();
        self.clear_uid();
        self.clear_user_sid();
        self.clear_visible();
        self.unknown_fields.clear();
    }
}

#[deriving(Clone,PartialEq,Default,Show)]
pub struct DenseInfo {
    version: ::std::vec::Vec<i32>,
    timestamp: ::std::vec::Vec<i64>,
    changeset: ::std::vec::Vec<i64>,
    uid: ::std::vec::Vec<i32>,
    user_sid: ::std::vec::Vec<i32>,
    visible: ::std::vec::Vec<bool>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> DenseInfo {
    pub fn new() -> DenseInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DenseInfo {
        static mut instance: ::protobuf::lazy::Lazy<DenseInfo> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const DenseInfo };
        unsafe {
            instance.get(|| {
                DenseInfo {
                    version: ::std::vec::Vec::new(),
                    timestamp: ::std::vec::Vec::new(),
                    changeset: ::std::vec::Vec::new(),
                    uid: ::std::vec::Vec::new(),
                    user_sid: ::std::vec::Vec::new(),
                    visible: ::std::vec::Vec::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    // repeated int32 version = 1;

    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::vec::Vec<i32>) {
        self.version = v;
    }

    // Mutable pointer to the field.
    pub fn mut_version(&'a mut self) -> &'a mut ::std::vec::Vec<i32> {
        &mut self.version
    }

    pub fn get_version(&'a self) -> &'a [i32] {
        self.version.as_slice()
    }

    // repeated sint64 timestamp = 2;

    pub fn clear_timestamp(&mut self) {
        self.timestamp.clear();
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: ::std::vec::Vec<i64>) {
        self.timestamp = v;
    }

    // Mutable pointer to the field.
    pub fn mut_timestamp(&'a mut self) -> &'a mut ::std::vec::Vec<i64> {
        &mut self.timestamp
    }

    pub fn get_timestamp(&'a self) -> &'a [i64] {
        self.timestamp.as_slice()
    }

    // repeated sint64 changeset = 3;

    pub fn clear_changeset(&mut self) {
        self.changeset.clear();
    }

    // Param is passed by value, moved
    pub fn set_changeset(&mut self, v: ::std::vec::Vec<i64>) {
        self.changeset = v;
    }

    // Mutable pointer to the field.
    pub fn mut_changeset(&'a mut self) -> &'a mut ::std::vec::Vec<i64> {
        &mut self.changeset
    }

    pub fn get_changeset(&'a self) -> &'a [i64] {
        self.changeset.as_slice()
    }

    // repeated sint32 uid = 4;

    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::vec::Vec<i32>) {
        self.uid = v;
    }

    // Mutable pointer to the field.
    pub fn mut_uid(&'a mut self) -> &'a mut ::std::vec::Vec<i32> {
        &mut self.uid
    }

    pub fn get_uid(&'a self) -> &'a [i32] {
        self.uid.as_slice()
    }

    // repeated sint32 user_sid = 5;

    pub fn clear_user_sid(&mut self) {
        self.user_sid.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_sid(&mut self, v: ::std::vec::Vec<i32>) {
        self.user_sid = v;
    }

    // Mutable pointer to the field.
    pub fn mut_user_sid(&'a mut self) -> &'a mut ::std::vec::Vec<i32> {
        &mut self.user_sid
    }

    pub fn get_user_sid(&'a self) -> &'a [i32] {
        self.user_sid.as_slice()
    }

    // repeated bool visible = 6;

    pub fn clear_visible(&mut self) {
        self.visible.clear();
    }

    // Param is passed by value, moved
    pub fn set_visible(&mut self, v: ::std::vec::Vec<bool>) {
        self.visible = v;
    }

    // Mutable pointer to the field.
    pub fn mut_visible(&'a mut self) -> &'a mut ::std::vec::Vec<bool> {
        &mut self.visible
    }

    pub fn get_visible(&'a self) -> &'a [bool] {
        self.visible.as_slice()
    }
}

impl ::protobuf::Message for DenseInfo {
    fn new() -> DenseInfo {
        DenseInfo::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type == ::protobuf::wire_format::WireTypeLengthDelimited {
                        let len = try!(is.read_raw_varint32());
                        let old_limit = is.push_limit(len);
                        while !try!(is.eof()) {
                            self.version.push(try!(is.read_int32()));
                        }
                        is.pop_limit(old_limit);
                    } else {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                        };
                        self.version.push(try!(is.read_int32()));
                    }
                },
                2 => {
                    if wire_type == ::protobuf::wire_format::WireTypeLengthDelimited {
                        let len = try!(is.read_raw_varint32());
                        let old_limit = is.push_limit(len);
                        while !try!(is.eof()) {
                            self.timestamp.push(try!(is.read_sint64()));
                        }
                        is.pop_limit(old_limit);
                    } else {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                        };
                        self.timestamp.push(try!(is.read_sint64()));
                    }
                },
                3 => {
                    if wire_type == ::protobuf::wire_format::WireTypeLengthDelimited {
                        let len = try!(is.read_raw_varint32());
                        let old_limit = is.push_limit(len);
                        while !try!(is.eof()) {
                            self.changeset.push(try!(is.read_sint64()));
                        }
                        is.pop_limit(old_limit);
                    } else {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                        };
                        self.changeset.push(try!(is.read_sint64()));
                    }
                },
                4 => {
                    if wire_type == ::protobuf::wire_format::WireTypeLengthDelimited {
                        let len = try!(is.read_raw_varint32());
                        let old_limit = is.push_limit(len);
                        while !try!(is.eof()) {
                            self.uid.push(try!(is.read_sint32()));
                        }
                        is.pop_limit(old_limit);
                    } else {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                        };
                        self.uid.push(try!(is.read_sint32()));
                    }
                },
                5 => {
                    if wire_type == ::protobuf::wire_format::WireTypeLengthDelimited {
                        let len = try!(is.read_raw_varint32());
                        let old_limit = is.push_limit(len);
                        while !try!(is.eof()) {
                            self.user_sid.push(try!(is.read_sint32()));
                        }
                        is.pop_limit(old_limit);
                    } else {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                        };
                        self.user_sid.push(try!(is.read_sint32()));
                    }
                },
                6 => {
                    if wire_type == ::protobuf::wire_format::WireTypeLengthDelimited {
                        let len = try!(is.read_raw_varint32());
                        let old_limit = is.push_limit(len);
                        while !try!(is.eof()) {
                            self.visible.push(try!(is.read_bool()));
                        }
                        is.pop_limit(old_limit);
                    } else {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                        };
                        self.visible.push(try!(is.read_bool()));
                    }
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Ok(())
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut ::std::vec::Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(1, self.version.as_slice());
        };
        if !self.timestamp.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_zigzag_size(2, self.timestamp.as_slice());
        };
        if !self.changeset.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_zigzag_size(3, self.changeset.as_slice());
        };
        if !self.uid.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_zigzag_size(4, self.uid.as_slice());
        };
        if !self.user_sid.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_zigzag_size(5, self.user_sid.as_slice());
        };
        if !self.visible.is_empty() {
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(self.visible.len() as u32) + (self.visible.len() * 1) as u32;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        sizes[pos] = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variables)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) -> ::protobuf::ProtobufResult<()> {
        use protobuf::{Message};
        if !self.version.is_empty() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(self.version.as_slice())));
            for v in self.version.iter() {
                try!(os.write_int32_no_tag(*v));
            };
        };
        if !self.timestamp.is_empty() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(::protobuf::rt::vec_packed_varint_zigzag_data_size(self.timestamp.as_slice())));
            for v in self.timestamp.iter() {
                try!(os.write_sint64_no_tag(*v));
            };
        };
        if !self.changeset.is_empty() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(::protobuf::rt::vec_packed_varint_zigzag_data_size(self.changeset.as_slice())));
            for v in self.changeset.iter() {
                try!(os.write_sint64_no_tag(*v));
            };
        };
        if !self.uid.is_empty() {
            try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(::protobuf::rt::vec_packed_varint_zigzag_data_size(self.uid.as_slice())));
            for v in self.uid.iter() {
                try!(os.write_sint32_no_tag(*v));
            };
        };
        if !self.user_sid.is_empty() {
            try!(os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(::protobuf::rt::vec_packed_varint_zigzag_data_size(self.user_sid.as_slice())));
            for v in self.user_sid.iter() {
                try!(os.write_sint32_no_tag(*v));
            };
        };
        if !self.visible.is_empty() {
            try!(os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32((self.visible.len() * 1) as u32));
            for v in self.visible.iter() {
                try!(os.write_bool_no_tag(*v));
            };
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Ok(())
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<DenseInfo>()
    }
}

impl ::protobuf::Clear for DenseInfo {
    fn clear(&mut self) {
        self.clear_version();
        self.clear_timestamp();
        self.clear_changeset();
        self.clear_uid();
        self.clear_user_sid();
        self.clear_visible();
        self.unknown_fields.clear();
    }
}

#[deriving(Clone,PartialEq,Default,Show)]
pub struct ChangeSet {
    id: ::std::option::Option<i64>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> ChangeSet {
    pub fn new() -> ChangeSet {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ChangeSet {
        static mut instance: ::protobuf::lazy::Lazy<ChangeSet> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ChangeSet };
        unsafe {
            instance.get(|| {
                ChangeSet {
                    id: ::std::option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    // required int64 id = 1;

    pub fn clear_id(&mut self) {
        self.id = None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = Some(v);
    }

    pub fn get_id(&self) -> i64 {
        self.id.unwrap_or(0)
    }
}

impl ::protobuf::Message for ChangeSet {
    fn new() -> ChangeSet {
        ChangeSet::new()
    }

    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int64());
                    self.id = Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Ok(())
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut ::std::vec::Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        sizes[pos] = my_size;
        // value is returned for convenience
        my_size
    }

    #[allow(unused_variables)]
    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) -> ::protobuf::ProtobufResult<()> {
        use protobuf::{Message};
        match self.id {
            Some(ref v) => {
                try!(os.write_int64(1, *v));
            },
            None => {},
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Ok(())
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<ChangeSet>()
    }
}

impl ::protobuf::Clear for ChangeSet {
    fn clear(&mut self) {
        self.clear_id();
        self.unknown_fields.clear();
    }
}

#[deriving(Clone,PartialEq,Default,Show)]
pub struct Node {
    id: ::std::option::Option<i64>,
    keys: ::std::vec::Vec<u32>,
    vals: ::std::vec::Vec<u32>,
    info: ::protobuf::SingularPtrField<Info>,
    lat: ::std::option::Option<i64>,
    lon: ::std::option::Option<i64>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> Node {
    pub fn new() -> Node {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Node {
        static mut instance: ::protobuf::lazy::Lazy<Node> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const Node };
        unsafe {
            instance.get(|| {
                Node {
                    id: ::std::option::None,
                    keys: ::std::vec::Vec::new(),
                    vals: ::std::vec::Vec::new(),
                    info: ::protobuf::SingularPtrField::none(),
                    lat: ::std::option::None,
                    lon: ::std::option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    // required sint64 id = 1;

    pub fn clear_id(&mut self) {
        self.id = None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = Some(v);
    }

    pub fn get_id(&self) -> i64 {
        self.id.unwrap_or(0)
    }

    // repeated uint32 keys = 2;

    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: ::std::vec::Vec<u32>) {
        self.keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys(&'a mut self) -> &'a mut ::std::vec::Vec<u32> {
        &mut self.keys
    }

    pub fn get_keys(&'a self) -> &'a [u32] {
        self.keys.as_slice()
    }

    // repeated uint32 vals = 3;

    pub fn clear_vals(&mut self) {
        self.vals.clear();
    }

    // Param is passed by value, moved
    pub fn set_vals(&mut self, v: ::std::vec::Vec<u32>) {
        self.vals = v;
    }

    // Mutable pointer to the field.
    pub fn mut_vals(&'a mut self) -> &'a mut ::std::vec::Vec<u32> {
        &mut self.vals
    }

    pub fn get_vals(&'a self) -> &'a [u32] {
        self.vals.as_slice()
    }

    // optional .OSMPBF.Info info = 4;

    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: Info) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&'a mut self) -> &'a mut Info {
        if self.info.is_none() {
            self.info.set_default();
        };
        self.info.as_mut().unwrap()
    }

    pub fn get_info(&'a self) -> &'a Info {
        self.info.as_ref().unwrap_or_else(|| Info::default_instance())
    }

    // required sint64 lat = 8;

    pub fn clear_lat(&mut self) {
        self.lat = None;
    }

    pub fn has_lat(&self) -> bool {
        self.lat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lat(&mut self, v: i64) {
        self.lat = Some(v);
    }

    pub fn get_lat(&self) -> i64 {
        self.lat.unwrap_or(0)
    }

    // required sint64 lon = 9;

    pub fn clear_lon(&mut self) {
        self.lon = None;
    }

    pub fn has_lon(&self) -> bool {
        self.lon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lon(&mut self, v: i64) {
        self.lon = Some(v);
    }

    pub fn get_lon(&self) -> i64 {
        self.lon.unwrap_or(0)
    }
}

impl ::protobuf::Message for Node {
    fn new() -> Node {
        Node::new()
    }

    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        };
        if self.lat.is_none() {
            return false;
        };
        if self.lon.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_sint64());
                    self.id = Some(tmp);
                },
                2 => {
                    if wire_type == ::protobuf::wire_format::WireTypeLengthDelimited {
                        let len = try!(is.read_raw_varint32());
                        let old_limit = is.push_limit(len);
                        while !try!(is.eof()) {
                            self.keys.push(try!(is.read_uint32()));
                        }
                        is.pop_limit(old_limit);
                    } else {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                        };
                        self.keys.push(try!(is.read_uint32()));
                    }
                },
                3 => {
                    if wire_type == ::protobuf::wire_format::WireTypeLengthDelimited {
                        let len = try!(is.read_raw_varint32());
                        let old_limit = is.push_limit(len);
                        while !try!(is.eof()) {
                            self.vals.push(try!(is.read_uint32()));
                        }
                        is.pop_limit(old_limit);
                    } else {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                        };
                        self.vals.push(try!(is.read_uint32()));
                    }
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.info.set_default();
                    try!(is.merge_message(tmp))
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_sint64());
                    self.lat = Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_sint64());
                    self.lon = Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Ok(())
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut ::std::vec::Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if !self.keys.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(2, self.keys.as_slice());
        };
        if !self.vals.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(3, self.vals.as_slice());
        };
        for value in self.info.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.lat.iter() {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.lon.iter() {
            my_size += ::protobuf::rt::value_size(9, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        sizes[pos] = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) -> ::protobuf::ProtobufResult<()> {
        use protobuf::{Message};
        match self.id {
            Some(ref v) => {
                try!(os.write_sint64(1, *v));
            },
            None => {},
        };
        if !self.keys.is_empty() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(self.keys.as_slice())));
            for v in self.keys.iter() {
                try!(os.write_uint32_no_tag(*v));
            };
        };
        if !self.vals.is_empty() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(self.vals.as_slice())));
            for v in self.vals.iter() {
                try!(os.write_uint32_no_tag(*v));
            };
        };
        match self.info.as_ref() {
            Some(ref v) => {
                try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
                try!(os.write_raw_varint32(sizes[*sizes_pos]));
                *sizes_pos += 1;
                try!(v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos));
            },
            None => {},
        };
        match self.lat {
            Some(ref v) => {
                try!(os.write_sint64(8, *v));
            },
            None => {},
        };
        match self.lon {
            Some(ref v) => {
                try!(os.write_sint64(9, *v));
            },
            None => {},
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Ok(())
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<Node>()
    }
}

impl ::protobuf::Clear for Node {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_keys();
        self.clear_vals();
        self.clear_info();
        self.clear_lat();
        self.clear_lon();
        self.unknown_fields.clear();
    }
}

#[deriving(Clone,PartialEq,Default,Show)]
pub struct DenseNodes {
    id: ::std::vec::Vec<i64>,
    denseinfo: ::protobuf::SingularPtrField<DenseInfo>,
    lat: ::std::vec::Vec<i64>,
    lon: ::std::vec::Vec<i64>,
    keys_vals: ::std::vec::Vec<i32>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> DenseNodes {
    pub fn new() -> DenseNodes {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DenseNodes {
        static mut instance: ::protobuf::lazy::Lazy<DenseNodes> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const DenseNodes };
        unsafe {
            instance.get(|| {
                DenseNodes {
                    id: ::std::vec::Vec::new(),
                    denseinfo: ::protobuf::SingularPtrField::none(),
                    lat: ::std::vec::Vec::new(),
                    lon: ::std::vec::Vec::new(),
                    keys_vals: ::std::vec::Vec::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    // repeated sint64 id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::vec::Vec<i64>) {
        self.id = v;
    }

    // Mutable pointer to the field.
    pub fn mut_id(&'a mut self) -> &'a mut ::std::vec::Vec<i64> {
        &mut self.id
    }

    pub fn get_id(&'a self) -> &'a [i64] {
        self.id.as_slice()
    }

    // optional .OSMPBF.DenseInfo denseinfo = 5;

    pub fn clear_denseinfo(&mut self) {
        self.denseinfo.clear();
    }

    pub fn has_denseinfo(&self) -> bool {
        self.denseinfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_denseinfo(&mut self, v: DenseInfo) {
        self.denseinfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_denseinfo(&'a mut self) -> &'a mut DenseInfo {
        if self.denseinfo.is_none() {
            self.denseinfo.set_default();
        };
        self.denseinfo.as_mut().unwrap()
    }

    pub fn get_denseinfo(&'a self) -> &'a DenseInfo {
        self.denseinfo.as_ref().unwrap_or_else(|| DenseInfo::default_instance())
    }

    // repeated sint64 lat = 8;

    pub fn clear_lat(&mut self) {
        self.lat.clear();
    }

    // Param is passed by value, moved
    pub fn set_lat(&mut self, v: ::std::vec::Vec<i64>) {
        self.lat = v;
    }

    // Mutable pointer to the field.
    pub fn mut_lat(&'a mut self) -> &'a mut ::std::vec::Vec<i64> {
        &mut self.lat
    }

    pub fn get_lat(&'a self) -> &'a [i64] {
        self.lat.as_slice()
    }

    // repeated sint64 lon = 9;

    pub fn clear_lon(&mut self) {
        self.lon.clear();
    }

    // Param is passed by value, moved
    pub fn set_lon(&mut self, v: ::std::vec::Vec<i64>) {
        self.lon = v;
    }

    // Mutable pointer to the field.
    pub fn mut_lon(&'a mut self) -> &'a mut ::std::vec::Vec<i64> {
        &mut self.lon
    }

    pub fn get_lon(&'a self) -> &'a [i64] {
        self.lon.as_slice()
    }

    // repeated int32 keys_vals = 10;

    pub fn clear_keys_vals(&mut self) {
        self.keys_vals.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys_vals(&mut self, v: ::std::vec::Vec<i32>) {
        self.keys_vals = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys_vals(&'a mut self) -> &'a mut ::std::vec::Vec<i32> {
        &mut self.keys_vals
    }

    pub fn get_keys_vals(&'a self) -> &'a [i32] {
        self.keys_vals.as_slice()
    }
}

impl ::protobuf::Message for DenseNodes {
    fn new() -> DenseNodes {
        DenseNodes::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type == ::protobuf::wire_format::WireTypeLengthDelimited {
                        let len = try!(is.read_raw_varint32());
                        let old_limit = is.push_limit(len);
                        while !try!(is.eof()) {
                            self.id.push(try!(is.read_sint64()));
                        }
                        is.pop_limit(old_limit);
                    } else {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                        };
                        self.id.push(try!(is.read_sint64()));
                    }
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.denseinfo.set_default();
                    try!(is.merge_message(tmp))
                },
                8 => {
                    if wire_type == ::protobuf::wire_format::WireTypeLengthDelimited {
                        let len = try!(is.read_raw_varint32());
                        let old_limit = is.push_limit(len);
                        while !try!(is.eof()) {
                            self.lat.push(try!(is.read_sint64()));
                        }
                        is.pop_limit(old_limit);
                    } else {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                        };
                        self.lat.push(try!(is.read_sint64()));
                    }
                },
                9 => {
                    if wire_type == ::protobuf::wire_format::WireTypeLengthDelimited {
                        let len = try!(is.read_raw_varint32());
                        let old_limit = is.push_limit(len);
                        while !try!(is.eof()) {
                            self.lon.push(try!(is.read_sint64()));
                        }
                        is.pop_limit(old_limit);
                    } else {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                        };
                        self.lon.push(try!(is.read_sint64()));
                    }
                },
                10 => {
                    if wire_type == ::protobuf::wire_format::WireTypeLengthDelimited {
                        let len = try!(is.read_raw_varint32());
                        let old_limit = is.push_limit(len);
                        while !try!(is.eof()) {
                            self.keys_vals.push(try!(is.read_int32()));
                        }
                        is.pop_limit(old_limit);
                    } else {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                        };
                        self.keys_vals.push(try!(is.read_int32()));
                    }
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Ok(())
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut ::std::vec::Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_zigzag_size(1, self.id.as_slice());
        };
        for value in self.denseinfo.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.lat.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_zigzag_size(8, self.lat.as_slice());
        };
        if !self.lon.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_zigzag_size(9, self.lon.as_slice());
        };
        if !self.keys_vals.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(10, self.keys_vals.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        sizes[pos] = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) -> ::protobuf::ProtobufResult<()> {
        use protobuf::{Message};
        if !self.id.is_empty() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(::protobuf::rt::vec_packed_varint_zigzag_data_size(self.id.as_slice())));
            for v in self.id.iter() {
                try!(os.write_sint64_no_tag(*v));
            };
        };
        match self.denseinfo.as_ref() {
            Some(ref v) => {
                try!(os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited));
                try!(os.write_raw_varint32(sizes[*sizes_pos]));
                *sizes_pos += 1;
                try!(v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos));
            },
            None => {},
        };
        if !self.lat.is_empty() {
            try!(os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(::protobuf::rt::vec_packed_varint_zigzag_data_size(self.lat.as_slice())));
            for v in self.lat.iter() {
                try!(os.write_sint64_no_tag(*v));
            };
        };
        if !self.lon.is_empty() {
            try!(os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(::protobuf::rt::vec_packed_varint_zigzag_data_size(self.lon.as_slice())));
            for v in self.lon.iter() {
                try!(os.write_sint64_no_tag(*v));
            };
        };
        if !self.keys_vals.is_empty() {
            try!(os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(self.keys_vals.as_slice())));
            for v in self.keys_vals.iter() {
                try!(os.write_int32_no_tag(*v));
            };
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Ok(())
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<DenseNodes>()
    }
}

impl ::protobuf::Clear for DenseNodes {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_denseinfo();
        self.clear_lat();
        self.clear_lon();
        self.clear_keys_vals();
        self.unknown_fields.clear();
    }
}

#[deriving(Clone,PartialEq,Default,Show)]
pub struct Way {
    id: ::std::option::Option<i64>,
    keys: ::std::vec::Vec<u32>,
    vals: ::std::vec::Vec<u32>,
    info: ::protobuf::SingularPtrField<Info>,
    refs: ::std::vec::Vec<i64>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> Way {
    pub fn new() -> Way {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Way {
        static mut instance: ::protobuf::lazy::Lazy<Way> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const Way };
        unsafe {
            instance.get(|| {
                Way {
                    id: ::std::option::None,
                    keys: ::std::vec::Vec::new(),
                    vals: ::std::vec::Vec::new(),
                    info: ::protobuf::SingularPtrField::none(),
                    refs: ::std::vec::Vec::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    // required int64 id = 1;

    pub fn clear_id(&mut self) {
        self.id = None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = Some(v);
    }

    pub fn get_id(&self) -> i64 {
        self.id.unwrap_or(0)
    }

    // repeated uint32 keys = 2;

    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: ::std::vec::Vec<u32>) {
        self.keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys(&'a mut self) -> &'a mut ::std::vec::Vec<u32> {
        &mut self.keys
    }

    pub fn get_keys(&'a self) -> &'a [u32] {
        self.keys.as_slice()
    }

    // repeated uint32 vals = 3;

    pub fn clear_vals(&mut self) {
        self.vals.clear();
    }

    // Param is passed by value, moved
    pub fn set_vals(&mut self, v: ::std::vec::Vec<u32>) {
        self.vals = v;
    }

    // Mutable pointer to the field.
    pub fn mut_vals(&'a mut self) -> &'a mut ::std::vec::Vec<u32> {
        &mut self.vals
    }

    pub fn get_vals(&'a self) -> &'a [u32] {
        self.vals.as_slice()
    }

    // optional .OSMPBF.Info info = 4;

    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: Info) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&'a mut self) -> &'a mut Info {
        if self.info.is_none() {
            self.info.set_default();
        };
        self.info.as_mut().unwrap()
    }

    pub fn get_info(&'a self) -> &'a Info {
        self.info.as_ref().unwrap_or_else(|| Info::default_instance())
    }

    // repeated sint64 refs = 8;

    pub fn clear_refs(&mut self) {
        self.refs.clear();
    }

    // Param is passed by value, moved
    pub fn set_refs(&mut self, v: ::std::vec::Vec<i64>) {
        self.refs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_refs(&'a mut self) -> &'a mut ::std::vec::Vec<i64> {
        &mut self.refs
    }

    pub fn get_refs(&'a self) -> &'a [i64] {
        self.refs.as_slice()
    }
}

impl ::protobuf::Message for Way {
    fn new() -> Way {
        Way::new()
    }

    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int64());
                    self.id = Some(tmp);
                },
                2 => {
                    if wire_type == ::protobuf::wire_format::WireTypeLengthDelimited {
                        let len = try!(is.read_raw_varint32());
                        let old_limit = is.push_limit(len);
                        while !try!(is.eof()) {
                            self.keys.push(try!(is.read_uint32()));
                        }
                        is.pop_limit(old_limit);
                    } else {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                        };
                        self.keys.push(try!(is.read_uint32()));
                    }
                },
                3 => {
                    if wire_type == ::protobuf::wire_format::WireTypeLengthDelimited {
                        let len = try!(is.read_raw_varint32());
                        let old_limit = is.push_limit(len);
                        while !try!(is.eof()) {
                            self.vals.push(try!(is.read_uint32()));
                        }
                        is.pop_limit(old_limit);
                    } else {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                        };
                        self.vals.push(try!(is.read_uint32()));
                    }
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.info.set_default();
                    try!(is.merge_message(tmp))
                },
                8 => {
                    if wire_type == ::protobuf::wire_format::WireTypeLengthDelimited {
                        let len = try!(is.read_raw_varint32());
                        let old_limit = is.push_limit(len);
                        while !try!(is.eof()) {
                            self.refs.push(try!(is.read_sint64()));
                        }
                        is.pop_limit(old_limit);
                    } else {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                        };
                        self.refs.push(try!(is.read_sint64()));
                    }
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Ok(())
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut ::std::vec::Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if !self.keys.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(2, self.keys.as_slice());
        };
        if !self.vals.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(3, self.vals.as_slice());
        };
        for value in self.info.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.refs.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_zigzag_size(8, self.refs.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        sizes[pos] = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) -> ::protobuf::ProtobufResult<()> {
        use protobuf::{Message};
        match self.id {
            Some(ref v) => {
                try!(os.write_int64(1, *v));
            },
            None => {},
        };
        if !self.keys.is_empty() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(self.keys.as_slice())));
            for v in self.keys.iter() {
                try!(os.write_uint32_no_tag(*v));
            };
        };
        if !self.vals.is_empty() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(self.vals.as_slice())));
            for v in self.vals.iter() {
                try!(os.write_uint32_no_tag(*v));
            };
        };
        match self.info.as_ref() {
            Some(ref v) => {
                try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
                try!(os.write_raw_varint32(sizes[*sizes_pos]));
                *sizes_pos += 1;
                try!(v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos));
            },
            None => {},
        };
        if !self.refs.is_empty() {
            try!(os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(::protobuf::rt::vec_packed_varint_zigzag_data_size(self.refs.as_slice())));
            for v in self.refs.iter() {
                try!(os.write_sint64_no_tag(*v));
            };
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Ok(())
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<Way>()
    }
}

impl ::protobuf::Clear for Way {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_keys();
        self.clear_vals();
        self.clear_info();
        self.clear_refs();
        self.unknown_fields.clear();
    }
}

#[deriving(Clone,PartialEq,Default,Show)]
pub struct Relation {
    id: ::std::option::Option<i64>,
    keys: ::std::vec::Vec<u32>,
    vals: ::std::vec::Vec<u32>,
    info: ::protobuf::SingularPtrField<Info>,
    roles_sid: ::std::vec::Vec<i32>,
    memids: ::std::vec::Vec<i64>,
    types: ::std::vec::Vec<Relation_MemberType>,
    unknown_fields: ::protobuf::UnknownFields,
}

impl<'a> Relation {
    pub fn new() -> Relation {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Relation {
        static mut instance: ::protobuf::lazy::Lazy<Relation> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const Relation };
        unsafe {
            instance.get(|| {
                Relation {
                    id: ::std::option::None,
                    keys: ::std::vec::Vec::new(),
                    vals: ::std::vec::Vec::new(),
                    info: ::protobuf::SingularPtrField::none(),
                    roles_sid: ::std::vec::Vec::new(),
                    memids: ::std::vec::Vec::new(),
                    types: ::std::vec::Vec::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                }
            })
        }
    }

    // required int64 id = 1;

    pub fn clear_id(&mut self) {
        self.id = None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = Some(v);
    }

    pub fn get_id(&self) -> i64 {
        self.id.unwrap_or(0)
    }

    // repeated uint32 keys = 2;

    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: ::std::vec::Vec<u32>) {
        self.keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys(&'a mut self) -> &'a mut ::std::vec::Vec<u32> {
        &mut self.keys
    }

    pub fn get_keys(&'a self) -> &'a [u32] {
        self.keys.as_slice()
    }

    // repeated uint32 vals = 3;

    pub fn clear_vals(&mut self) {
        self.vals.clear();
    }

    // Param is passed by value, moved
    pub fn set_vals(&mut self, v: ::std::vec::Vec<u32>) {
        self.vals = v;
    }

    // Mutable pointer to the field.
    pub fn mut_vals(&'a mut self) -> &'a mut ::std::vec::Vec<u32> {
        &mut self.vals
    }

    pub fn get_vals(&'a self) -> &'a [u32] {
        self.vals.as_slice()
    }

    // optional .OSMPBF.Info info = 4;

    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: Info) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&'a mut self) -> &'a mut Info {
        if self.info.is_none() {
            self.info.set_default();
        };
        self.info.as_mut().unwrap()
    }

    pub fn get_info(&'a self) -> &'a Info {
        self.info.as_ref().unwrap_or_else(|| Info::default_instance())
    }

    // repeated int32 roles_sid = 8;

    pub fn clear_roles_sid(&mut self) {
        self.roles_sid.clear();
    }

    // Param is passed by value, moved
    pub fn set_roles_sid(&mut self, v: ::std::vec::Vec<i32>) {
        self.roles_sid = v;
    }

    // Mutable pointer to the field.
    pub fn mut_roles_sid(&'a mut self) -> &'a mut ::std::vec::Vec<i32> {
        &mut self.roles_sid
    }

    pub fn get_roles_sid(&'a self) -> &'a [i32] {
        self.roles_sid.as_slice()
    }

    // repeated sint64 memids = 9;

    pub fn clear_memids(&mut self) {
        self.memids.clear();
    }

    // Param is passed by value, moved
    pub fn set_memids(&mut self, v: ::std::vec::Vec<i64>) {
        self.memids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_memids(&'a mut self) -> &'a mut ::std::vec::Vec<i64> {
        &mut self.memids
    }

    pub fn get_memids(&'a self) -> &'a [i64] {
        self.memids.as_slice()
    }

    // repeated .OSMPBF.Relation.MemberType types = 10;

    pub fn clear_types(&mut self) {
        self.types.clear();
    }

    // Param is passed by value, moved
    pub fn set_types(&mut self, v: ::std::vec::Vec<Relation_MemberType>) {
        self.types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_types(&'a mut self) -> &'a mut ::std::vec::Vec<Relation_MemberType> {
        &mut self.types
    }

    pub fn get_types(&'a self) -> &'a [Relation_MemberType] {
        self.types.as_slice()
    }
}

impl ::protobuf::Message for Relation {
    fn new() -> Relation {
        Relation::new()
    }

    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int64());
                    self.id = Some(tmp);
                },
                2 => {
                    if wire_type == ::protobuf::wire_format::WireTypeLengthDelimited {
                        let len = try!(is.read_raw_varint32());
                        let old_limit = is.push_limit(len);
                        while !try!(is.eof()) {
                            self.keys.push(try!(is.read_uint32()));
                        }
                        is.pop_limit(old_limit);
                    } else {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                        };
                        self.keys.push(try!(is.read_uint32()));
                    }
                },
                3 => {
                    if wire_type == ::protobuf::wire_format::WireTypeLengthDelimited {
                        let len = try!(is.read_raw_varint32());
                        let old_limit = is.push_limit(len);
                        while !try!(is.eof()) {
                            self.vals.push(try!(is.read_uint32()));
                        }
                        is.pop_limit(old_limit);
                    } else {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                        };
                        self.vals.push(try!(is.read_uint32()));
                    }
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.info.set_default();
                    try!(is.merge_message(tmp))
                },
                8 => {
                    if wire_type == ::protobuf::wire_format::WireTypeLengthDelimited {
                        let len = try!(is.read_raw_varint32());
                        let old_limit = is.push_limit(len);
                        while !try!(is.eof()) {
                            self.roles_sid.push(try!(is.read_int32()));
                        }
                        is.pop_limit(old_limit);
                    } else {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                        };
                        self.roles_sid.push(try!(is.read_int32()));
                    }
                },
                9 => {
                    if wire_type == ::protobuf::wire_format::WireTypeLengthDelimited {
                        let len = try!(is.read_raw_varint32());
                        let old_limit = is.push_limit(len);
                        while !try!(is.eof()) {
                            self.memids.push(try!(is.read_sint64()));
                        }
                        is.pop_limit(old_limit);
                    } else {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                        };
                        self.memids.push(try!(is.read_sint64()));
                    }
                },
                10 => {
                    if wire_type == ::protobuf::wire_format::WireTypeLengthDelimited {
                        let len = try!(is.read_raw_varint32());
                        let old_limit = is.push_limit(len);
                        while !try!(is.eof()) {
                            self.types.push(Relation_MemberType::new(try!(is.read_int32())));
                        }
                        is.pop_limit(old_limit);
                    } else {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                        };
                        self.types.push(Relation_MemberType::new(try!(is.read_int32())));
                    }
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Ok(())
    }

    // Compute sizes of nested messages
    fn compute_sizes(&self, sizes: &mut ::std::vec::Vec<u32>) -> u32 {
        use protobuf::{Message};
        let pos = sizes.len();
        sizes.push(0);
        let mut my_size = 0;
        for value in self.id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if !self.keys.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(2, self.keys.as_slice());
        };
        if !self.vals.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(3, self.vals.as_slice());
        };
        for value in self.info.iter() {
            let len = value.compute_sizes(sizes);
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.roles_sid.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(8, self.roles_sid.as_slice());
        };
        if !self.memids.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_zigzag_size(9, self.memids.as_slice());
        };
        if !self.types.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(10, self.types.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        sizes[pos] = my_size;
        // value is returned for convenience
        my_size
    }

    fn write_to_with_computed_sizes(&self, os: &mut ::protobuf::CodedOutputStream, sizes: &[u32], sizes_pos: &mut uint) -> ::protobuf::ProtobufResult<()> {
        use protobuf::{Message};
        match self.id {
            Some(ref v) => {
                try!(os.write_int64(1, *v));
            },
            None => {},
        };
        if !self.keys.is_empty() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(self.keys.as_slice())));
            for v in self.keys.iter() {
                try!(os.write_uint32_no_tag(*v));
            };
        };
        if !self.vals.is_empty() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(self.vals.as_slice())));
            for v in self.vals.iter() {
                try!(os.write_uint32_no_tag(*v));
            };
        };
        match self.info.as_ref() {
            Some(ref v) => {
                try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
                try!(os.write_raw_varint32(sizes[*sizes_pos]));
                *sizes_pos += 1;
                try!(v.write_to_with_computed_sizes(os, sizes.as_slice(), sizes_pos));
            },
            None => {},
        };
        if !self.roles_sid.is_empty() {
            try!(os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(self.roles_sid.as_slice())));
            for v in self.roles_sid.iter() {
                try!(os.write_int32_no_tag(*v));
            };
        };
        if !self.memids.is_empty() {
            try!(os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(::protobuf::rt::vec_packed_varint_zigzag_data_size(self.memids.as_slice())));
            for v in self.memids.iter() {
                try!(os.write_sint64_no_tag(*v));
            };
        };
        if !self.types.is_empty() {
            try!(os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(self.types.as_slice())));
            for v in self.types.iter() {
                try!(os.write_enum_no_tag(*v as i32));
            };
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Ok(())
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<Relation>()
    }
}

impl ::protobuf::Clear for Relation {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_keys();
        self.clear_vals();
        self.clear_info();
        self.clear_roles_sid();
        self.clear_memids();
        self.clear_types();
        self.unknown_fields.clear();
    }
}

#[deriving(Clone,PartialEq,Eq,Show)]
pub enum Relation_MemberType {
    NODE = 0,
    WAY = 1,
    RELATION = 2,
}

impl Relation_MemberType {
    pub fn new(value: i32) -> Relation_MemberType {
        match value {
            0 => Relation_MemberType::NODE,
            1 => Relation_MemberType::WAY,
            2 => Relation_MemberType::RELATION,
            _ => panic!()
        }
    }
}

impl ::protobuf::ProtobufEnum for Relation_MemberType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn enum_descriptor_static(_: Option<Relation_MemberType>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::reflect::EnumDescriptor };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Relation_MemberType", file_descriptor_proto())
            })
        }
    }
}

impl ::protobuf::rt::ProtobufVarint for Relation_MemberType {
    fn len_varint(&self) -> u32 {
        use protobuf::ProtobufEnum;
        self.value().len_varint()
    }
}

static file_descriptor_proto_data: &'static [u8] = &[
    0x0a, 0x0f, 0x6f, 0x73, 0x6d, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74,
    0x6f, 0x12, 0x06, 0x4f, 0x53, 0x4d, 0x50, 0x42, 0x46, 0x22, 0x87, 0x02, 0x0a, 0x0b, 0x48, 0x65,
    0x61, 0x64, 0x65, 0x72, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x12, 0x20, 0x0a, 0x04, 0x62, 0x62, 0x6f,
    0x78, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x4f, 0x53, 0x4d, 0x50, 0x42, 0x46,
    0x2e, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x42, 0x42, 0x6f, 0x78, 0x12, 0x19, 0x0a, 0x11, 0x72,
    0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x5f, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73,
    0x18, 0x04, 0x20, 0x03, 0x28, 0x09, 0x12, 0x19, 0x0a, 0x11, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e,
    0x61, 0x6c, 0x5f, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28,
    0x09, 0x12, 0x16, 0x0a, 0x0e, 0x77, 0x72, 0x69, 0x74, 0x69, 0x6e, 0x67, 0x70, 0x72, 0x6f, 0x67,
    0x72, 0x61, 0x6d, 0x18, 0x10, 0x20, 0x01, 0x28, 0x09, 0x12, 0x0e, 0x0a, 0x06, 0x73, 0x6f, 0x75,
    0x72, 0x63, 0x65, 0x18, 0x11, 0x20, 0x01, 0x28, 0x09, 0x12, 0x25, 0x0a, 0x1d, 0x6f, 0x73, 0x6d,
    0x6f, 0x73, 0x69, 0x73, 0x5f, 0x72, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e,
    0x5f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x20, 0x20, 0x01, 0x28, 0x03,
    0x12, 0x2b, 0x0a, 0x23, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x69, 0x73, 0x5f, 0x72, 0x65, 0x70, 0x6c,
    0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x65,
    0x5f, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x18, 0x21, 0x20, 0x01, 0x28, 0x03, 0x12, 0x24, 0x0a,
    0x1c, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x69, 0x73, 0x5f, 0x72, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61,
    0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x62, 0x61, 0x73, 0x65, 0x5f, 0x75, 0x72, 0x6c, 0x18, 0x22, 0x20,
    0x01, 0x28, 0x09, 0x22, 0x46, 0x0a, 0x0a, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x42, 0x42, 0x6f,
    0x78, 0x12, 0x0c, 0x0a, 0x04, 0x6c, 0x65, 0x66, 0x74, 0x18, 0x01, 0x20, 0x02, 0x28, 0x12, 0x12,
    0x0d, 0x0a, 0x05, 0x72, 0x69, 0x67, 0x68, 0x74, 0x18, 0x02, 0x20, 0x02, 0x28, 0x12, 0x12, 0x0b,
    0x0a, 0x03, 0x74, 0x6f, 0x70, 0x18, 0x03, 0x20, 0x02, 0x28, 0x12, 0x12, 0x0e, 0x0a, 0x06, 0x62,
    0x6f, 0x74, 0x74, 0x6f, 0x6d, 0x18, 0x04, 0x20, 0x02, 0x28, 0x12, 0x22, 0xd2, 0x01, 0x0a, 0x0e,
    0x50, 0x72, 0x69, 0x6d, 0x69, 0x74, 0x69, 0x76, 0x65, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x12, 0x28,
    0x0a, 0x0b, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x18, 0x01, 0x20,
    0x02, 0x28, 0x0b, 0x32, 0x13, 0x2e, 0x4f, 0x53, 0x4d, 0x50, 0x42, 0x46, 0x2e, 0x53, 0x74, 0x72,
    0x69, 0x6e, 0x67, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x12, 0x2e, 0x0a, 0x0e, 0x70, 0x72, 0x69, 0x6d,
    0x69, 0x74, 0x69, 0x76, 0x65, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b,
    0x32, 0x16, 0x2e, 0x4f, 0x53, 0x4d, 0x50, 0x42, 0x46, 0x2e, 0x50, 0x72, 0x69, 0x6d, 0x69, 0x74,
    0x69, 0x76, 0x65, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x12, 0x18, 0x0a, 0x0b, 0x67, 0x72, 0x61, 0x6e,
    0x75, 0x6c, 0x61, 0x72, 0x69, 0x74, 0x79, 0x18, 0x11, 0x20, 0x01, 0x28, 0x05, 0x3a, 0x03, 0x31,
    0x30, 0x30, 0x12, 0x15, 0x0a, 0x0a, 0x6c, 0x61, 0x74, 0x5f, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74,
    0x18, 0x13, 0x20, 0x01, 0x28, 0x03, 0x3a, 0x01, 0x30, 0x12, 0x15, 0x0a, 0x0a, 0x6c, 0x6f, 0x6e,
    0x5f, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x18, 0x14, 0x20, 0x01, 0x28, 0x03, 0x3a, 0x01, 0x30,
    0x12, 0x1e, 0x0a, 0x10, 0x64, 0x61, 0x74, 0x65, 0x5f, 0x67, 0x72, 0x61, 0x6e, 0x75, 0x6c, 0x61,
    0x72, 0x69, 0x74, 0x79, 0x18, 0x12, 0x20, 0x01, 0x28, 0x05, 0x3a, 0x04, 0x31, 0x30, 0x30, 0x30,
    0x22, 0xb7, 0x01, 0x0a, 0x0e, 0x50, 0x72, 0x69, 0x6d, 0x69, 0x74, 0x69, 0x76, 0x65, 0x47, 0x72,
    0x6f, 0x75, 0x70, 0x12, 0x1b, 0x0a, 0x05, 0x6e, 0x6f, 0x64, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03,
    0x28, 0x0b, 0x32, 0x0c, 0x2e, 0x4f, 0x53, 0x4d, 0x50, 0x42, 0x46, 0x2e, 0x4e, 0x6f, 0x64, 0x65,
    0x12, 0x21, 0x0a, 0x05, 0x64, 0x65, 0x6e, 0x73, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32,
    0x12, 0x2e, 0x4f, 0x53, 0x4d, 0x50, 0x42, 0x46, 0x2e, 0x44, 0x65, 0x6e, 0x73, 0x65, 0x4e, 0x6f,
    0x64, 0x65, 0x73, 0x12, 0x19, 0x0a, 0x04, 0x77, 0x61, 0x79, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28,
    0x0b, 0x32, 0x0b, 0x2e, 0x4f, 0x53, 0x4d, 0x50, 0x42, 0x46, 0x2e, 0x57, 0x61, 0x79, 0x12, 0x23,
    0x0a, 0x09, 0x72, 0x65, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28,
    0x0b, 0x32, 0x10, 0x2e, 0x4f, 0x53, 0x4d, 0x50, 0x42, 0x46, 0x2e, 0x52, 0x65, 0x6c, 0x61, 0x74,
    0x69, 0x6f, 0x6e, 0x12, 0x25, 0x0a, 0x0a, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x65, 0x74,
    0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x4f, 0x53, 0x4d, 0x50, 0x42, 0x46,
    0x2e, 0x43, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x53, 0x65, 0x74, 0x22, 0x18, 0x0a, 0x0b, 0x53, 0x74,
    0x72, 0x69, 0x6e, 0x67, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x12, 0x09, 0x0a, 0x01, 0x73, 0x18, 0x01,
    0x20, 0x03, 0x28, 0x0c, 0x22, 0x71, 0x0a, 0x04, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x13, 0x0a, 0x07,
    0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x3a, 0x02, 0x2d,
    0x31, 0x12, 0x11, 0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x02,
    0x20, 0x01, 0x28, 0x03, 0x12, 0x11, 0x0a, 0x09, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x65,
    0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x12, 0x0b, 0x0a, 0x03, 0x75, 0x69, 0x64, 0x18, 0x04,
    0x20, 0x01, 0x28, 0x05, 0x12, 0x10, 0x0a, 0x08, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x73, 0x69, 0x64,
    0x18, 0x05, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x0f, 0x0a, 0x07, 0x76, 0x69, 0x73, 0x69, 0x62, 0x6c,
    0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x22, 0x8a, 0x01, 0x0a, 0x09, 0x44, 0x65, 0x6e, 0x73,
    0x65, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x13, 0x0a, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e,
    0x18, 0x01, 0x20, 0x03, 0x28, 0x05, 0x42, 0x02, 0x10, 0x01, 0x12, 0x15, 0x0a, 0x09, 0x74, 0x69,
    0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x02, 0x20, 0x03, 0x28, 0x12, 0x42, 0x02, 0x10,
    0x01, 0x12, 0x15, 0x0a, 0x09, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x65, 0x74, 0x18, 0x03,
    0x20, 0x03, 0x28, 0x12, 0x42, 0x02, 0x10, 0x01, 0x12, 0x0f, 0x0a, 0x03, 0x75, 0x69, 0x64, 0x18,
    0x04, 0x20, 0x03, 0x28, 0x11, 0x42, 0x02, 0x10, 0x01, 0x12, 0x14, 0x0a, 0x08, 0x75, 0x73, 0x65,
    0x72, 0x5f, 0x73, 0x69, 0x64, 0x18, 0x05, 0x20, 0x03, 0x28, 0x11, 0x42, 0x02, 0x10, 0x01, 0x12,
    0x13, 0x0a, 0x07, 0x76, 0x69, 0x73, 0x69, 0x62, 0x6c, 0x65, 0x18, 0x06, 0x20, 0x03, 0x28, 0x08,
    0x42, 0x02, 0x10, 0x01, 0x22, 0x17, 0x0a, 0x09, 0x43, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x53, 0x65,
    0x74, 0x12, 0x0a, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x02, 0x28, 0x03, 0x22, 0x6c, 0x0a,
    0x04, 0x4e, 0x6f, 0x64, 0x65, 0x12, 0x0a, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x02, 0x28,
    0x12, 0x12, 0x10, 0x0a, 0x04, 0x6b, 0x65, 0x79, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0d, 0x42,
    0x02, 0x10, 0x01, 0x12, 0x10, 0x0a, 0x04, 0x76, 0x61, 0x6c, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28,
    0x0d, 0x42, 0x02, 0x10, 0x01, 0x12, 0x1a, 0x0a, 0x04, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x04, 0x20,
    0x01, 0x28, 0x0b, 0x32, 0x0c, 0x2e, 0x4f, 0x53, 0x4d, 0x50, 0x42, 0x46, 0x2e, 0x49, 0x6e, 0x66,
    0x6f, 0x12, 0x0b, 0x0a, 0x03, 0x6c, 0x61, 0x74, 0x18, 0x08, 0x20, 0x02, 0x28, 0x12, 0x12, 0x0b,
    0x0a, 0x03, 0x6c, 0x6f, 0x6e, 0x18, 0x09, 0x20, 0x02, 0x28, 0x12, 0x22, 0x7b, 0x0a, 0x0a, 0x44,
    0x65, 0x6e, 0x73, 0x65, 0x4e, 0x6f, 0x64, 0x65, 0x73, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18,
    0x01, 0x20, 0x03, 0x28, 0x12, 0x42, 0x02, 0x10, 0x01, 0x12, 0x24, 0x0a, 0x09, 0x64, 0x65, 0x6e,
    0x73, 0x65, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x4f,
    0x53, 0x4d, 0x50, 0x42, 0x46, 0x2e, 0x44, 0x65, 0x6e, 0x73, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x12,
    0x0f, 0x0a, 0x03, 0x6c, 0x61, 0x74, 0x18, 0x08, 0x20, 0x03, 0x28, 0x12, 0x42, 0x02, 0x10, 0x01,
    0x12, 0x0f, 0x0a, 0x03, 0x6c, 0x6f, 0x6e, 0x18, 0x09, 0x20, 0x03, 0x28, 0x12, 0x42, 0x02, 0x10,
    0x01, 0x12, 0x15, 0x0a, 0x09, 0x6b, 0x65, 0x79, 0x73, 0x5f, 0x76, 0x61, 0x6c, 0x73, 0x18, 0x0a,
    0x20, 0x03, 0x28, 0x05, 0x42, 0x02, 0x10, 0x01, 0x22, 0x63, 0x0a, 0x03, 0x57, 0x61, 0x79, 0x12,
    0x0a, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x02, 0x28, 0x03, 0x12, 0x10, 0x0a, 0x04, 0x6b,
    0x65, 0x79, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0d, 0x42, 0x02, 0x10, 0x01, 0x12, 0x10, 0x0a,
    0x04, 0x76, 0x61, 0x6c, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0d, 0x42, 0x02, 0x10, 0x01, 0x12,
    0x1a, 0x0a, 0x04, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0c, 0x2e,
    0x4f, 0x53, 0x4d, 0x50, 0x42, 0x46, 0x2e, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x10, 0x0a, 0x04, 0x72,
    0x65, 0x66, 0x73, 0x18, 0x08, 0x20, 0x03, 0x28, 0x12, 0x42, 0x02, 0x10, 0x01, 0x22, 0xe0, 0x01,
    0x0a, 0x08, 0x52, 0x65, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x0a, 0x0a, 0x02, 0x69, 0x64,
    0x18, 0x01, 0x20, 0x02, 0x28, 0x03, 0x12, 0x10, 0x0a, 0x04, 0x6b, 0x65, 0x79, 0x73, 0x18, 0x02,
    0x20, 0x03, 0x28, 0x0d, 0x42, 0x02, 0x10, 0x01, 0x12, 0x10, 0x0a, 0x04, 0x76, 0x61, 0x6c, 0x73,
    0x18, 0x03, 0x20, 0x03, 0x28, 0x0d, 0x42, 0x02, 0x10, 0x01, 0x12, 0x1a, 0x0a, 0x04, 0x69, 0x6e,
    0x66, 0x6f, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0c, 0x2e, 0x4f, 0x53, 0x4d, 0x50, 0x42,
    0x46, 0x2e, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x15, 0x0a, 0x09, 0x72, 0x6f, 0x6c, 0x65, 0x73, 0x5f,
    0x73, 0x69, 0x64, 0x18, 0x08, 0x20, 0x03, 0x28, 0x05, 0x42, 0x02, 0x10, 0x01, 0x12, 0x12, 0x0a,
    0x06, 0x6d, 0x65, 0x6d, 0x69, 0x64, 0x73, 0x18, 0x09, 0x20, 0x03, 0x28, 0x12, 0x42, 0x02, 0x10,
    0x01, 0x12, 0x2e, 0x0a, 0x05, 0x74, 0x79, 0x70, 0x65, 0x73, 0x18, 0x0a, 0x20, 0x03, 0x28, 0x0e,
    0x32, 0x1b, 0x2e, 0x4f, 0x53, 0x4d, 0x50, 0x42, 0x46, 0x2e, 0x52, 0x65, 0x6c, 0x61, 0x74, 0x69,
    0x6f, 0x6e, 0x2e, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x42, 0x02, 0x10,
    0x01, 0x22, 0x2d, 0x0a, 0x0a, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x12,
    0x08, 0x0a, 0x04, 0x4e, 0x4f, 0x44, 0x45, 0x10, 0x00, 0x12, 0x07, 0x0a, 0x03, 0x57, 0x41, 0x59,
    0x10, 0x01, 0x12, 0x0c, 0x0a, 0x08, 0x52, 0x45, 0x4c, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x10, 0x02,
    0x42, 0x11, 0x0a, 0x0d, 0x63, 0x72, 0x6f, 0x73, 0x62, 0x79, 0x2e, 0x62, 0x69, 0x6e, 0x61, 0x72,
    0x79, 0x48, 0x03, 0x4a, 0xac, 0x4e, 0x0a, 0x07, 0x12, 0x05, 0x11, 0x00, 0x82, 0x02, 0x01, 0x0a,
    0x08, 0x0a, 0x01, 0x08, 0x12, 0x03, 0x11, 0x00, 0x23, 0x0a, 0x0b, 0x0a, 0x04, 0x08, 0xe7, 0x07,
    0x00, 0x12, 0x03, 0x11, 0x00, 0x23, 0x0a, 0x0c, 0x0a, 0x05, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x12,
    0x03, 0x11, 0x07, 0x13, 0x0a, 0x0d, 0x0a, 0x06, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x12, 0x03,
    0x11, 0x07, 0x13, 0x0a, 0x0e, 0x0a, 0x07, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x01, 0x12, 0x03,
    0x11, 0x07, 0x13, 0x0a, 0x0c, 0x0a, 0x05, 0x08, 0xe7, 0x07, 0x00, 0x03, 0x12, 0x03, 0x11, 0x16,
    0x22, 0x0a, 0x08, 0x0a, 0x01, 0x08, 0x12, 0x03, 0x12, 0x00, 0x26, 0x0a, 0x0b, 0x0a, 0x04, 0x08,
    0xe7, 0x07, 0x01, 0x12, 0x03, 0x12, 0x00, 0x26, 0x0a, 0x0c, 0x0a, 0x05, 0x08, 0xe7, 0x07, 0x01,
    0x02, 0x12, 0x03, 0x12, 0x07, 0x13, 0x0a, 0x0d, 0x0a, 0x06, 0x08, 0xe7, 0x07, 0x01, 0x02, 0x00,
    0x12, 0x03, 0x12, 0x07, 0x13, 0x0a, 0x0e, 0x0a, 0x07, 0x08, 0xe7, 0x07, 0x01, 0x02, 0x00, 0x01,
    0x12, 0x03, 0x12, 0x07, 0x13, 0x0a, 0x0c, 0x0a, 0x05, 0x08, 0xe7, 0x07, 0x01, 0x07, 0x12, 0x03,
    0x12, 0x16, 0x25, 0x0a, 0x08, 0x0a, 0x01, 0x02, 0x12, 0x03, 0x13, 0x08, 0x0e, 0x0a, 0x0a, 0x0a,
    0x02, 0x04, 0x00, 0x12, 0x04, 0x38, 0x00, 0x4d, 0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x00, 0x01,
    0x12, 0x03, 0x38, 0x08, 0x13, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x00, 0x02, 0x00, 0x12, 0x03, 0x39,
    0x02, 0x1f, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x00, 0x04, 0x12, 0x03, 0x39, 0x02, 0x0a,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x00, 0x06, 0x12, 0x03, 0x39, 0x0b, 0x15, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x00, 0x02, 0x00, 0x01, 0x12, 0x03, 0x39, 0x16, 0x1a, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x00, 0x02, 0x00, 0x03, 0x12, 0x03, 0x39, 0x1d, 0x1e, 0x0a, 0x3d, 0x0a, 0x04, 0x04, 0x00,
    0x02, 0x01, 0x12, 0x03, 0x3b, 0x02, 0x28, 0x1a, 0x30, 0x20, 0x41, 0x64, 0x64, 0x69, 0x74, 0x69,
    0x6f, 0x6e, 0x61, 0x6c, 0x20, 0x74, 0x61, 0x67, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x69, 0x64,
    0x20, 0x69, 0x6e, 0x20, 0x70, 0x61, 0x72, 0x73, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x69, 0x73,
    0x20, 0x64, 0x61, 0x74, 0x61, 0x73, 0x65, 0x74, 0x20, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02,
    0x01, 0x04, 0x12, 0x03, 0x3b, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x01, 0x05,
    0x12, 0x03, 0x3b, 0x0b, 0x11, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x01, 0x01, 0x12, 0x03,
    0x3b, 0x12, 0x23, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x01, 0x03, 0x12, 0x03, 0x3b, 0x26,
    0x27, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x00, 0x02, 0x02, 0x12, 0x03, 0x3c, 0x02, 0x28, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x00, 0x02, 0x02, 0x04, 0x12, 0x03, 0x3c, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x00, 0x02, 0x02, 0x05, 0x12, 0x03, 0x3c, 0x0b, 0x11, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00,
    0x02, 0x02, 0x01, 0x12, 0x03, 0x3c, 0x12, 0x23, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x02,
    0x03, 0x12, 0x03, 0x3c, 0x26, 0x27, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x00, 0x02, 0x03, 0x12, 0x03,
    0x3e, 0x02, 0x26, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x03, 0x04, 0x12, 0x03, 0x3e, 0x02,
    0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x03, 0x05, 0x12, 0x03, 0x3e, 0x0b, 0x11, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x03, 0x01, 0x12, 0x03, 0x3e, 0x12, 0x20, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x00, 0x02, 0x03, 0x03, 0x12, 0x03, 0x3e, 0x23, 0x25, 0x0a, 0x23, 0x0a, 0x04, 0x04,
    0x00, 0x02, 0x04, 0x12, 0x03, 0x3f, 0x02, 0x1e, 0x22, 0x16, 0x20, 0x46, 0x72, 0x6f, 0x6d, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x62, 0x62, 0x6f, 0x78, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x2e, 0x0a,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x04, 0x04, 0x12, 0x03, 0x3f, 0x02, 0x0a, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x00, 0x02, 0x04, 0x05, 0x12, 0x03, 0x3f, 0x0b, 0x11, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x00, 0x02, 0x04, 0x01, 0x12, 0x03, 0x3f, 0x12, 0x18, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00,
    0x02, 0x04, 0x03, 0x12, 0x03, 0x3f, 0x1b, 0x1d, 0x0a, 0xae, 0x01, 0x0a, 0x04, 0x04, 0x00, 0x02,
    0x05, 0x12, 0x03, 0x46, 0x02, 0x34, 0x1a, 0xa0, 0x01, 0x20, 0x72, 0x65, 0x70, 0x6c, 0x69, 0x63,
    0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x2c,
    0x20, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x73, 0x65,
    0x63, 0x6f, 0x6e, 0x64, 0x73, 0x20, 0x73, 0x69, 0x6e, 0x63, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x65, 0x70, 0x6f, 0x63, 0x68, 0x2c, 0x20, 0x0a, 0x20, 0x6f, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69,
    0x73, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6d, 0x65, 0x20, 0x76, 0x61, 0x6c, 0x75,
    0x65, 0x20, 0x61, 0x73, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x22, 0x74, 0x69, 0x6d,
    0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x3d, 0x2e, 0x2e, 0x2e, 0x22, 0x20, 0x66, 0x69, 0x65, 0x6c,
    0x64, 0x0a, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x2e,
    0x74, 0x78, 0x74, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x62, 0x79,
    0x20, 0x4f, 0x73, 0x6d, 0x6f, 0x73, 0x69, 0x73, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02,
    0x05, 0x04, 0x12, 0x03, 0x46, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x05, 0x05,
    0x12, 0x03, 0x46, 0x0b, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x05, 0x01, 0x12, 0x03,
    0x46, 0x11, 0x2e, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x05, 0x03, 0x12, 0x03, 0x46, 0x31,
    0x33, 0x0a, 0x48, 0x0a, 0x04, 0x04, 0x00, 0x02, 0x06, 0x12, 0x03, 0x49, 0x02, 0x3a, 0x1a, 0x3b,
    0x20, 0x72, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x73, 0x65, 0x71,
    0x75, 0x65, 0x6e, 0x63, 0x65, 0x20, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x20, 0x28, 0x73, 0x65,
    0x71, 0x75, 0x65, 0x6e, 0x63, 0x65, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x20, 0x69, 0x6e, 0x20,
    0x73, 0x74, 0x61, 0x74, 0x65, 0x2e, 0x74, 0x78, 0x74, 0x29, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x00, 0x02, 0x06, 0x04, 0x12, 0x03, 0x49, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02,
    0x06, 0x05, 0x12, 0x03, 0x49, 0x0b, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x06, 0x01,
    0x12, 0x03, 0x49, 0x11, 0x34, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x06, 0x03, 0x12, 0x03,
    0x49, 0x37, 0x39, 0x0a, 0x4a, 0x0a, 0x04, 0x04, 0x00, 0x02, 0x07, 0x12, 0x03, 0x4c, 0x02, 0x34,
    0x1a, 0x3d, 0x20, 0x72, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x62,
    0x61, 0x73, 0x65, 0x20, 0x55, 0x52, 0x4c, 0x20, 0x28, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x4f, 0x73,
    0x6d, 0x6f, 0x73, 0x69, 0x73, 0x27, 0x20, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72, 0x61,
    0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x74, 0x78, 0x74, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x29, 0x0a, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x07, 0x04, 0x12, 0x03, 0x4c, 0x02, 0x0a, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x00, 0x02, 0x07, 0x05, 0x12, 0x03, 0x4c, 0x0b, 0x11, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x00, 0x02, 0x07, 0x01, 0x12, 0x03, 0x4c, 0x12, 0x2e, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02,
    0x07, 0x03, 0x12, 0x03, 0x4c, 0x31, 0x33, 0x0a, 0x0a, 0x0a, 0x02, 0x04, 0x01, 0x12, 0x04, 0x54,
    0x00, 0x59, 0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x01, 0x01, 0x12, 0x03, 0x54, 0x08, 0x12, 0x0a,
    0x0b, 0x0a, 0x04, 0x04, 0x01, 0x02, 0x00, 0x12, 0x03, 0x55, 0x03, 0x1c, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x01, 0x02, 0x00, 0x04, 0x12, 0x03, 0x55, 0x03, 0x0b, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01,
    0x02, 0x00, 0x05, 0x12, 0x03, 0x55, 0x0c, 0x12, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x00,
    0x01, 0x12, 0x03, 0x55, 0x13, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x00, 0x03, 0x12,
    0x03, 0x55, 0x1a, 0x1b, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x01, 0x02, 0x01, 0x12, 0x03, 0x56, 0x03,
    0x1d, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x01, 0x04, 0x12, 0x03, 0x56, 0x03, 0x0b, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x01, 0x05, 0x12, 0x03, 0x56, 0x0c, 0x12, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x01, 0x02, 0x01, 0x01, 0x12, 0x03, 0x56, 0x13, 0x18, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x01, 0x02, 0x01, 0x03, 0x12, 0x03, 0x56, 0x1b, 0x1c, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x01, 0x02,
    0x02, 0x12, 0x03, 0x57, 0x03, 0x1b, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x02, 0x04, 0x12,
    0x03, 0x57, 0x03, 0x0b, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x02, 0x05, 0x12, 0x03, 0x57,
    0x0c, 0x12, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x02, 0x01, 0x12, 0x03, 0x57, 0x13, 0x16,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x02, 0x03, 0x12, 0x03, 0x57, 0x19, 0x1a, 0x0a, 0x0b,
    0x0a, 0x04, 0x04, 0x01, 0x02, 0x03, 0x12, 0x03, 0x58, 0x03, 0x1e, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x01, 0x02, 0x03, 0x04, 0x12, 0x03, 0x58, 0x03, 0x0b, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02,
    0x03, 0x05, 0x12, 0x03, 0x58, 0x0c, 0x12, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x03, 0x01,
    0x12, 0x03, 0x58, 0x13, 0x19, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x03, 0x03, 0x12, 0x03,
    0x58, 0x1c, 0x1d, 0x0a, 0x0a, 0x0a, 0x02, 0x04, 0x02, 0x12, 0x04, 0x60, 0x00, 0x70, 0x01, 0x0a,
    0x0a, 0x0a, 0x03, 0x04, 0x02, 0x01, 0x12, 0x03, 0x60, 0x08, 0x16, 0x0a, 0x0b, 0x0a, 0x04, 0x04,
    0x02, 0x02, 0x00, 0x12, 0x03, 0x61, 0x02, 0x27, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x00,
    0x04, 0x12, 0x03, 0x61, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x00, 0x06, 0x12,
    0x03, 0x61, 0x0b, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x00, 0x01, 0x12, 0x03, 0x61,
    0x17, 0x22, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x00, 0x03, 0x12, 0x03, 0x61, 0x25, 0x26,
    0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x02, 0x02, 0x01, 0x12, 0x03, 0x62, 0x02, 0x2d, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x02, 0x02, 0x01, 0x04, 0x12, 0x03, 0x62, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x02, 0x02, 0x01, 0x06, 0x12, 0x03, 0x62, 0x0b, 0x19, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02,
    0x01, 0x01, 0x12, 0x03, 0x62, 0x1a, 0x28, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x01, 0x03,
    0x12, 0x03, 0x62, 0x2b, 0x2c, 0x0a, 0x59, 0x0a, 0x04, 0x04, 0x02, 0x02, 0x02, 0x12, 0x03, 0x65,
    0x02, 0x30, 0x1a, 0x4c, 0x20, 0x47, 0x72, 0x61, 0x6e, 0x75, 0x6c, 0x61, 0x72, 0x69, 0x74, 0x79,
    0x2c, 0x20, 0x75, 0x6e, 0x69, 0x74, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x6e, 0x61, 0x6e, 0x6f, 0x64,
    0x65, 0x67, 0x72, 0x65, 0x65, 0x73, 0x2c, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20,
    0x73, 0x74, 0x6f, 0x72, 0x65, 0x20, 0x63, 0x6f, 0x6f, 0x72, 0x64, 0x69, 0x6e, 0x61, 0x74, 0x65,
    0x73, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x0a,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x02, 0x04, 0x12, 0x03, 0x65, 0x02, 0x0a, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x02, 0x02, 0x02, 0x05, 0x12, 0x03, 0x65, 0x0b, 0x10, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x02, 0x02, 0x02, 0x01, 0x12, 0x03, 0x65, 0x11, 0x1c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02,
    0x02, 0x02, 0x03, 0x12, 0x03, 0x65, 0x1f, 0x21, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x02,
    0x08, 0x12, 0x03, 0x65, 0x22, 0x2f, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x02, 0x07, 0x12,
    0x03, 0x65, 0x2b, 0x2e, 0x0a, 0x79, 0x0a, 0x04, 0x04, 0x02, 0x02, 0x03, 0x12, 0x03, 0x67, 0x02,
    0x2d, 0x1a, 0x6c, 0x20, 0x4f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65,
    0x20, 0x62, 0x65, 0x74, 0x77, 0x65, 0x65, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6f, 0x75, 0x74,
    0x70, 0x75, 0x74, 0x20, 0x63, 0x6f, 0x6f, 0x72, 0x64, 0x69, 0x6e, 0x61, 0x74, 0x65, 0x73, 0x20,
    0x63, 0x6f, 0x6f, 0x72, 0x64, 0x69, 0x6e, 0x61, 0x74, 0x65, 0x73, 0x20, 0x61, 0x6e, 0x64, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x67, 0x72, 0x61, 0x6e, 0x75, 0x6c, 0x61, 0x72, 0x69, 0x74, 0x79, 0x20,
    0x67, 0x72, 0x69, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x75, 0x6e, 0x69, 0x74, 0x65, 0x73, 0x20, 0x6f,
    0x66, 0x20, 0x6e, 0x61, 0x6e, 0x6f, 0x64, 0x65, 0x67, 0x72, 0x65, 0x65, 0x73, 0x2e, 0x0a, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x03, 0x04, 0x12, 0x03, 0x67, 0x02, 0x0a, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x02, 0x02, 0x03, 0x05, 0x12, 0x03, 0x67, 0x0b, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x02, 0x02, 0x03, 0x01, 0x12, 0x03, 0x67, 0x11, 0x1b, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02,
    0x03, 0x03, 0x12, 0x03, 0x67, 0x1e, 0x20, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x03, 0x08,
    0x12, 0x03, 0x67, 0x21, 0x2c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x03, 0x07, 0x12, 0x03,
    0x67, 0x2a, 0x2b, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x02, 0x02, 0x04, 0x12, 0x03, 0x68, 0x02, 0x2d,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x04, 0x04, 0x12, 0x03, 0x68, 0x02, 0x0a, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x02, 0x02, 0x04, 0x05, 0x12, 0x03, 0x68, 0x0b, 0x10, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x02, 0x02, 0x04, 0x01, 0x12, 0x03, 0x68, 0x11, 0x1b, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02,
    0x02, 0x04, 0x03, 0x12, 0x03, 0x68, 0x1e, 0x20, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x04,
    0x08, 0x12, 0x03, 0x68, 0x21, 0x2c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x04, 0x07, 0x12,
    0x03, 0x68, 0x2a, 0x2b, 0x0a, 0x68, 0x0a, 0x04, 0x04, 0x02, 0x02, 0x05, 0x12, 0x03, 0x6b, 0x02,
    0x36, 0x1a, 0x5b, 0x20, 0x47, 0x72, 0x61, 0x6e, 0x75, 0x6c, 0x61, 0x72, 0x69, 0x74, 0x79, 0x20,
    0x6f, 0x66, 0x20, 0x64, 0x61, 0x74, 0x65, 0x73, 0x2c, 0x20, 0x6e, 0x6f, 0x72, 0x6d, 0x61, 0x6c,
    0x6c, 0x79, 0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x65, 0x64, 0x20, 0x69,
    0x6e, 0x20, 0x75, 0x6e, 0x69, 0x74, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x6d, 0x69, 0x6c, 0x6c, 0x69,
    0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x20, 0x73, 0x69, 0x6e, 0x63, 0x65, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x31, 0x39, 0x37, 0x30, 0x20, 0x65, 0x70, 0x6f, 0x63, 0x68, 0x2e, 0x0a, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x02, 0x02, 0x05, 0x04, 0x12, 0x03, 0x6b, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x02, 0x02, 0x05, 0x05, 0x12, 0x03, 0x6b, 0x0b, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02,
    0x02, 0x05, 0x01, 0x12, 0x03, 0x6b, 0x11, 0x21, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x05,
    0x03, 0x12, 0x03, 0x6b, 0x24, 0x26, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x05, 0x08, 0x12,
    0x03, 0x6b, 0x27, 0x35, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x05, 0x07, 0x12, 0x03, 0x6b,
    0x30, 0x34, 0x0a, 0x56, 0x0a, 0x02, 0x04, 0x03, 0x12, 0x04, 0x73, 0x00, 0x79, 0x01, 0x1a, 0x4a,
    0x20, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x20, 0x6f, 0x66, 0x20, 0x4f, 0x53, 0x4d, 0x50, 0x72, 0x69,
    0x6d, 0x69, 0x74, 0x69, 0x76, 0x65, 0x73, 0x2e, 0x20, 0x41, 0x6c, 0x6c, 0x20, 0x70, 0x72, 0x69,
    0x6d, 0x69, 0x74, 0x69, 0x76, 0x65, 0x73, 0x20, 0x69, 0x6e, 0x20, 0x61, 0x20, 0x67, 0x72, 0x6f,
    0x75, 0x70, 0x20, 0x6d, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73,
    0x61, 0x6d, 0x65, 0x20, 0x74, 0x79, 0x70, 0x65, 0x2e, 0x0a, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x03,
    0x01, 0x12, 0x03, 0x73, 0x08, 0x16, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x03, 0x02, 0x00, 0x12, 0x03,
    0x74, 0x02, 0x1e, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x00, 0x04, 0x12, 0x03, 0x74, 0x02,
    0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x00, 0x06, 0x12, 0x03, 0x74, 0x0b, 0x0f, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x00, 0x01, 0x12, 0x03, 0x74, 0x14, 0x19, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x03, 0x02, 0x00, 0x03, 0x12, 0x03, 0x74, 0x1c, 0x1d, 0x0a, 0x0b, 0x0a, 0x04, 0x04,
    0x03, 0x02, 0x01, 0x12, 0x03, 0x75, 0x02, 0x20, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x01,
    0x04, 0x12, 0x03, 0x75, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x01, 0x06, 0x12,
    0x03, 0x75, 0x0b, 0x15, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x01, 0x01, 0x12, 0x03, 0x75,
    0x16, 0x1b, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x01, 0x03, 0x12, 0x03, 0x75, 0x1e, 0x1f,
    0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x03, 0x02, 0x02, 0x12, 0x03, 0x76, 0x02, 0x1d, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x03, 0x02, 0x02, 0x04, 0x12, 0x03, 0x76, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x03, 0x02, 0x02, 0x06, 0x12, 0x03, 0x76, 0x0b, 0x0e, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02,
    0x02, 0x01, 0x12, 0x03, 0x76, 0x14, 0x18, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x02, 0x03,
    0x12, 0x03, 0x76, 0x1b, 0x1c, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x03, 0x02, 0x03, 0x12, 0x03, 0x77,
    0x02, 0x22, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x03, 0x04, 0x12, 0x03, 0x77, 0x02, 0x0a,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x03, 0x06, 0x12, 0x03, 0x77, 0x0b, 0x13, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x03, 0x02, 0x03, 0x01, 0x12, 0x03, 0x77, 0x14, 0x1d, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x03, 0x02, 0x03, 0x03, 0x12, 0x03, 0x77, 0x20, 0x21, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x03,
    0x02, 0x04, 0x12, 0x03, 0x78, 0x02, 0x24, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x04, 0x04,
    0x12, 0x03, 0x78, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x04, 0x06, 0x12, 0x03,
    0x78, 0x0b, 0x14, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x04, 0x01, 0x12, 0x03, 0x78, 0x15,
    0x1f, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x04, 0x03, 0x12, 0x03, 0x78, 0x22, 0x23, 0x0a,
    0xbf, 0x01, 0x0a, 0x02, 0x04, 0x04, 0x12, 0x06, 0x82, 0x01, 0x00, 0x84, 0x01, 0x01, 0x1a, 0xb0,
    0x01, 0x2a, 0x20, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x2c,
    0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6f,
    0x6d, 0x6d, 0x6f, 0x6e, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x73, 0x20, 0x69, 0x6e, 0x20,
    0x65, 0x61, 0x63, 0x68, 0x20, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x2e, 0x0a, 0x0a, 0x4e, 0x6f, 0x74,
    0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x77, 0x65, 0x20, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76,
    0x65, 0x20, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x20, 0x27, 0x30, 0x27, 0x20, 0x61, 0x73, 0x20, 0x61,
    0x20, 0x64, 0x65, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x72, 0x2c, 0x20, 0x73, 0x6f, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x65, 0x6e, 0x74, 0x72, 0x79, 0x20, 0x61, 0x74, 0x20, 0x74, 0x68, 0x61, 0x74,
    0x0a, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x61,
    0x62, 0x6c, 0x65, 0x20, 0x69, 0x73, 0x20, 0x41, 0x4c, 0x57, 0x41, 0x59, 0x53, 0x20, 0x62, 0x6c,
    0x61, 0x6e, 0x6b, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x75, 0x6e, 0x75, 0x73, 0x65, 0x64, 0x2e, 0x0a,
    0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x04, 0x01, 0x12, 0x04, 0x82, 0x01, 0x08, 0x13, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x04, 0x02, 0x00, 0x12, 0x04, 0x83, 0x01, 0x03, 0x18, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x04, 0x02, 0x00, 0x04, 0x12, 0x04, 0x83, 0x01, 0x03, 0x0b, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x04, 0x02, 0x00, 0x05, 0x12, 0x04, 0x83, 0x01, 0x0c, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x04,
    0x02, 0x00, 0x01, 0x12, 0x04, 0x83, 0x01, 0x12, 0x13, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x04, 0x02,
    0x00, 0x03, 0x12, 0x04, 0x83, 0x01, 0x16, 0x17, 0x0a, 0x4b, 0x0a, 0x02, 0x04, 0x05, 0x12, 0x06,
    0x87, 0x01, 0x00, 0x97, 0x01, 0x01, 0x1a, 0x3d, 0x20, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x61,
    0x6c, 0x20, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20,
    0x6d, 0x61, 0x79, 0x20, 0x62, 0x65, 0x20, 0x69, 0x6e, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x64, 0x20,
    0x69, 0x6e, 0x74, 0x6f, 0x20, 0x65, 0x61, 0x63, 0x68, 0x20, 0x70, 0x72, 0x69, 0x6d, 0x69, 0x74,
    0x69, 0x76, 0x65, 0x2e, 0x20, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x05, 0x01, 0x12, 0x04, 0x87, 0x01,
    0x08, 0x0c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x00, 0x12, 0x04, 0x88, 0x01, 0x03, 0x2d,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x00, 0x04, 0x12, 0x04, 0x88, 0x01, 0x03, 0x0b, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x00, 0x05, 0x12, 0x04, 0x88, 0x01, 0x0c, 0x11, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x05, 0x02, 0x00, 0x01, 0x12, 0x04, 0x88, 0x01, 0x12, 0x19, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x05, 0x02, 0x00, 0x03, 0x12, 0x04, 0x88, 0x01, 0x1c, 0x1d, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x05, 0x02, 0x00, 0x08, 0x12, 0x04, 0x88, 0x01, 0x1e, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x05, 0x02, 0x00, 0x07, 0x12, 0x04, 0x88, 0x01, 0x29, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x05,
    0x02, 0x01, 0x12, 0x04, 0x89, 0x01, 0x03, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x01,
    0x04, 0x12, 0x04, 0x89, 0x01, 0x03, 0x0b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x01, 0x05,
    0x12, 0x04, 0x89, 0x01, 0x0c, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x01, 0x01, 0x12,
    0x04, 0x89, 0x01, 0x12, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x01, 0x03, 0x12, 0x04,
    0x89, 0x01, 0x1e, 0x1f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x02, 0x12, 0x04, 0x8a, 0x01,
    0x03, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x02, 0x04, 0x12, 0x04, 0x8a, 0x01, 0x03,
    0x0b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x02, 0x05, 0x12, 0x04, 0x8a, 0x01, 0x0c, 0x11,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x02, 0x01, 0x12, 0x04, 0x8a, 0x01, 0x12, 0x1b, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x02, 0x03, 0x12, 0x04, 0x8a, 0x01, 0x1e, 0x1f, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x05, 0x02, 0x03, 0x12, 0x04, 0x8b, 0x01, 0x03, 0x1a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x05, 0x02, 0x03, 0x04, 0x12, 0x04, 0x8b, 0x01, 0x03, 0x0b, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x05, 0x02, 0x03, 0x05, 0x12, 0x04, 0x8b, 0x01, 0x0c, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05,
    0x02, 0x03, 0x01, 0x12, 0x04, 0x8b, 0x01, 0x12, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02,
    0x03, 0x03, 0x12, 0x04, 0x8b, 0x01, 0x18, 0x19, 0x0a, 0x1a, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x04,
    0x12, 0x04, 0x8c, 0x01, 0x03, 0x20, 0x22, 0x0c, 0x20, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x20,
    0x49, 0x44, 0x73, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x04, 0x04, 0x12, 0x04, 0x8c,
    0x01, 0x03, 0x0b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x04, 0x05, 0x12, 0x04, 0x8c, 0x01,
    0x0c, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x04, 0x01, 0x12, 0x04, 0x8c, 0x01, 0x13,
    0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x04, 0x03, 0x12, 0x04, 0x8c, 0x01, 0x1e, 0x1f,
    0x0a, 0xbe, 0x03, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x05, 0x12, 0x04, 0x96, 0x01, 0x03, 0x1d, 0x1a,
    0xaf, 0x03, 0x20, 0x54, 0x68, 0x65, 0x20, 0x76, 0x69, 0x73, 0x69, 0x62, 0x6c, 0x65, 0x20, 0x66,
    0x6c, 0x61, 0x67, 0x20, 0x69, 0x73, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x73,
    0x74, 0x6f, 0x72, 0x65, 0x20, 0x68, 0x69, 0x73, 0x74, 0x6f, 0x72, 0x79, 0x20, 0x69, 0x6e, 0x66,
    0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x20, 0x49, 0x74, 0x20, 0x69, 0x6e, 0x64,
    0x69, 0x63, 0x61, 0x74, 0x65, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x0a, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x20, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x20,
    0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x68, 0x61, 0x73, 0x20, 0x62, 0x65, 0x65, 0x6e,
    0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x61, 0x20, 0x64, 0x65,
    0x6c, 0x65, 0x74, 0x65, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6f,
    0x6e, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x4f, 0x53, 0x4d, 0x20, 0x41, 0x50, 0x49, 0x2e, 0x0a,
    0x20, 0x57, 0x68, 0x65, 0x6e, 0x20, 0x61, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x72, 0x20, 0x73,
    0x65, 0x74, 0x73, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x66, 0x6c, 0x61, 0x67, 0x2c, 0x20, 0x69,
    0x74, 0x20, 0x4d, 0x55, 0x53, 0x54, 0x20, 0x61, 0x64, 0x64, 0x20, 0x61, 0x20, 0x72, 0x65, 0x71,
    0x75, 0x69, 0x72, 0x65, 0x64, 0x5f, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x20, 0x74,
    0x61, 0x67, 0x20, 0x77, 0x69, 0x74, 0x68, 0x0a, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x20, 0x22,
    0x48, 0x69, 0x73, 0x74, 0x6f, 0x72, 0x69, 0x63, 0x61, 0x6c, 0x49, 0x6e, 0x66, 0x6f, 0x72, 0x6d,
    0x61, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x48, 0x65,
    0x61, 0x64, 0x65, 0x72, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x2e, 0x0a, 0x20, 0x49, 0x66, 0x20, 0x74,
    0x68, 0x69, 0x73, 0x20, 0x66, 0x6c, 0x61, 0x67, 0x20, 0x69, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x20,
    0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x73, 0x6f,
    0x6d, 0x65, 0x20, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x20, 0x69, 0x74, 0x20, 0x4d, 0x55, 0x53,
    0x54, 0x20, 0x62, 0x65, 0x20, 0x61, 0x73, 0x73, 0x75, 0x6d, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20,
    0x62, 0x65, 0x0a, 0x20, 0x74, 0x72, 0x75, 0x65, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x66, 0x69, 0x6c, 0x65, 0x20, 0x68, 0x61, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x71,
    0x75, 0x69, 0x72, 0x65, 0x64, 0x5f, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x20, 0x74,
    0x61, 0x67, 0x20, 0x22, 0x48, 0x69, 0x73, 0x74, 0x6f, 0x72, 0x69, 0x63, 0x61, 0x6c, 0x49, 0x6e,
    0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x0a, 0x20, 0x73, 0x65, 0x74, 0x2e,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x05, 0x04, 0x12, 0x04, 0x96, 0x01, 0x03, 0x0b,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x05, 0x05, 0x12, 0x04, 0x96, 0x01, 0x0c, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x05, 0x01, 0x12, 0x04, 0x96, 0x01, 0x11, 0x18, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x05, 0x02, 0x05, 0x03, 0x12, 0x04, 0x96, 0x01, 0x1b, 0x1c, 0x0a, 0x75, 0x0a,
    0x02, 0x04, 0x06, 0x12, 0x06, 0x9a, 0x01, 0x00, 0xaa, 0x01, 0x01, 0x1a, 0x67, 0x2a, 0x20, 0x4f,
    0x70, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x20, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61,
    0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x6d, 0x61, 0x79, 0x20, 0x62, 0x65, 0x20, 0x69, 0x6e, 0x63,
    0x6c, 0x75, 0x64, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x74, 0x6f, 0x20, 0x65, 0x61, 0x63, 0x68, 0x20,
    0x70, 0x72, 0x69, 0x6d, 0x69, 0x74, 0x69, 0x76, 0x65, 0x2e, 0x20, 0x53, 0x70, 0x65, 0x63, 0x69,
    0x61, 0x6c, 0x20, 0x64, 0x65, 0x6e, 0x73, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x20,
    0x75, 0x73, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x44, 0x65, 0x6e, 0x73, 0x65, 0x4e, 0x6f, 0x64,
    0x65, 0x73, 0x2e, 0x20, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x06, 0x01, 0x12, 0x04, 0x9a, 0x01, 0x08,
    0x11, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x06, 0x02, 0x00, 0x12, 0x04, 0x9b, 0x01, 0x03, 0x2e, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x00, 0x04, 0x12, 0x04, 0x9b, 0x01, 0x03, 0x0b, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x06, 0x02, 0x00, 0x05, 0x12, 0x04, 0x9b, 0x01, 0x0c, 0x11, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x06, 0x02, 0x00, 0x01, 0x12, 0x04, 0x9b, 0x01, 0x12, 0x19, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x06, 0x02, 0x00, 0x03, 0x12, 0x04, 0x9b, 0x01, 0x1c, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x06, 0x02, 0x00, 0x08, 0x12, 0x04, 0x9b, 0x01, 0x1e, 0x2d, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x06,
    0x02, 0x00, 0x08, 0xe7, 0x07, 0x00, 0x12, 0x04, 0x9b, 0x01, 0x1f, 0x2c, 0x0a, 0x11, 0x0a, 0x09,
    0x04, 0x06, 0x02, 0x00, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x12, 0x04, 0x9b, 0x01, 0x1f, 0x25, 0x0a,
    0x12, 0x0a, 0x0a, 0x04, 0x06, 0x02, 0x00, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x12, 0x04, 0x9b,
    0x01, 0x1f, 0x25, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x06, 0x02, 0x00, 0x08, 0xe7, 0x07, 0x00, 0x02,
    0x00, 0x01, 0x12, 0x04, 0x9b, 0x01, 0x1f, 0x25, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x06, 0x02, 0x00,
    0x08, 0xe7, 0x07, 0x00, 0x03, 0x12, 0x04, 0x9b, 0x01, 0x28, 0x2c, 0x0a, 0x1b, 0x0a, 0x04, 0x04,
    0x06, 0x02, 0x01, 0x12, 0x04, 0x9c, 0x01, 0x03, 0x31, 0x22, 0x0d, 0x20, 0x44, 0x45, 0x4c, 0x54,
    0x41, 0x20, 0x63, 0x6f, 0x64, 0x65, 0x64, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x01,
    0x04, 0x12, 0x04, 0x9c, 0x01, 0x03, 0x0b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x01, 0x05,
    0x12, 0x04, 0x9c, 0x01, 0x0c, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x01, 0x01, 0x12,
    0x04, 0x9c, 0x01, 0x13, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x01, 0x03, 0x12, 0x04,
    0x9c, 0x01, 0x1f, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x01, 0x08, 0x12, 0x04, 0x9c,
    0x01, 0x21, 0x30, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x06, 0x02, 0x01, 0x08, 0xe7, 0x07, 0x00, 0x12,
    0x04, 0x9c, 0x01, 0x22, 0x2f, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x06, 0x02, 0x01, 0x08, 0xe7, 0x07,
    0x00, 0x02, 0x12, 0x04, 0x9c, 0x01, 0x22, 0x28, 0x0a, 0x12, 0x0a, 0x0a, 0x04, 0x06, 0x02, 0x01,
    0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x12, 0x04, 0x9c, 0x01, 0x22, 0x28, 0x0a, 0x13, 0x0a, 0x0b,
    0x04, 0x06, 0x02, 0x01, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0x9c, 0x01, 0x22,
    0x28, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x06, 0x02, 0x01, 0x08, 0xe7, 0x07, 0x00, 0x03, 0x12, 0x04,
    0x9c, 0x01, 0x2b, 0x2f, 0x0a, 0x1b, 0x0a, 0x04, 0x04, 0x06, 0x02, 0x02, 0x12, 0x04, 0x9d, 0x01,
    0x03, 0x31, 0x22, 0x0d, 0x20, 0x44, 0x45, 0x4c, 0x54, 0x41, 0x20, 0x63, 0x6f, 0x64, 0x65, 0x64,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x02, 0x04, 0x12, 0x04, 0x9d, 0x01, 0x03, 0x0b,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x02, 0x05, 0x12, 0x04, 0x9d, 0x01, 0x0c, 0x12, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x02, 0x01, 0x12, 0x04, 0x9d, 0x01, 0x13, 0x1c, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x06, 0x02, 0x02, 0x03, 0x12, 0x04, 0x9d, 0x01, 0x1f, 0x20, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x06, 0x02, 0x02, 0x08, 0x12, 0x04, 0x9d, 0x01, 0x21, 0x30, 0x0a, 0x10, 0x0a, 0x08,
    0x04, 0x06, 0x02, 0x02, 0x08, 0xe7, 0x07, 0x00, 0x12, 0x04, 0x9d, 0x01, 0x22, 0x2f, 0x0a, 0x11,
    0x0a, 0x09, 0x04, 0x06, 0x02, 0x02, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x12, 0x04, 0x9d, 0x01, 0x22,
    0x28, 0x0a, 0x12, 0x0a, 0x0a, 0x04, 0x06, 0x02, 0x02, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x12,
    0x04, 0x9d, 0x01, 0x22, 0x28, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x06, 0x02, 0x02, 0x08, 0xe7, 0x07,
    0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0x9d, 0x01, 0x22, 0x28, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x06,
    0x02, 0x02, 0x08, 0xe7, 0x07, 0x00, 0x03, 0x12, 0x04, 0x9d, 0x01, 0x2b, 0x2f, 0x0a, 0x1b, 0x0a,
    0x04, 0x04, 0x06, 0x02, 0x03, 0x12, 0x04, 0x9e, 0x01, 0x03, 0x2b, 0x22, 0x0d, 0x20, 0x44, 0x45,
    0x4c, 0x54, 0x41, 0x20, 0x63, 0x6f, 0x64, 0x65, 0x64, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06,
    0x02, 0x03, 0x04, 0x12, 0x04, 0x9e, 0x01, 0x03, 0x0b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02,
    0x03, 0x05, 0x12, 0x04, 0x9e, 0x01, 0x0c, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x03,
    0x01, 0x12, 0x04, 0x9e, 0x01, 0x13, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x03, 0x03,
    0x12, 0x04, 0x9e, 0x01, 0x19, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x03, 0x08, 0x12,
    0x04, 0x9e, 0x01, 0x1b, 0x2a, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x06, 0x02, 0x03, 0x08, 0xe7, 0x07,
    0x00, 0x12, 0x04, 0x9e, 0x01, 0x1c, 0x29, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x06, 0x02, 0x03, 0x08,
    0xe7, 0x07, 0x00, 0x02, 0x12, 0x04, 0x9e, 0x01, 0x1c, 0x22, 0x0a, 0x12, 0x0a, 0x0a, 0x04, 0x06,
    0x02, 0x03, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x12, 0x04, 0x9e, 0x01, 0x1c, 0x22, 0x0a, 0x13,
    0x0a, 0x0b, 0x04, 0x06, 0x02, 0x03, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0x9e,
    0x01, 0x1c, 0x22, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x06, 0x02, 0x03, 0x08, 0xe7, 0x07, 0x00, 0x03,
    0x12, 0x04, 0x9e, 0x01, 0x25, 0x29, 0x0a, 0x35, 0x0a, 0x04, 0x04, 0x06, 0x02, 0x04, 0x12, 0x04,
    0x9f, 0x01, 0x03, 0x30, 0x22, 0x27, 0x20, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x20, 0x49, 0x44,
    0x73, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x2e,
    0x20, 0x44, 0x45, 0x4c, 0x54, 0x41, 0x20, 0x63, 0x6f, 0x64, 0x65, 0x64, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x06, 0x02, 0x04, 0x04, 0x12, 0x04, 0x9f, 0x01, 0x03, 0x0b, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x06, 0x02, 0x04, 0x05, 0x12, 0x04, 0x9f, 0x01, 0x0c, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x06, 0x02, 0x04, 0x01, 0x12, 0x04, 0x9f, 0x01, 0x13, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06,
    0x02, 0x04, 0x03, 0x12, 0x04, 0x9f, 0x01, 0x1e, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02,
    0x04, 0x08, 0x12, 0x04, 0x9f, 0x01, 0x20, 0x2f, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x06, 0x02, 0x04,
    0x08, 0xe7, 0x07, 0x00, 0x12, 0x04, 0x9f, 0x01, 0x21, 0x2e, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x06,
    0x02, 0x04, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x12, 0x04, 0x9f, 0x01, 0x21, 0x27, 0x0a, 0x12, 0x0a,
    0x0a, 0x04, 0x06, 0x02, 0x04, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x12, 0x04, 0x9f, 0x01, 0x21,
    0x27, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x06, 0x02, 0x04, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x01,
    0x12, 0x04, 0x9f, 0x01, 0x21, 0x27, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x06, 0x02, 0x04, 0x08, 0xe7,
    0x07, 0x00, 0x03, 0x12, 0x04, 0x9f, 0x01, 0x2a, 0x2e, 0x0a, 0xbe, 0x03, 0x0a, 0x04, 0x04, 0x06,
    0x02, 0x05, 0x12, 0x04, 0xa9, 0x01, 0x03, 0x2d, 0x1a, 0xaf, 0x03, 0x20, 0x54, 0x68, 0x65, 0x20,
    0x76, 0x69, 0x73, 0x69, 0x62, 0x6c, 0x65, 0x20, 0x66, 0x6c, 0x61, 0x67, 0x20, 0x69, 0x73, 0x20,
    0x75, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x20, 0x68, 0x69,
    0x73, 0x74, 0x6f, 0x72, 0x79, 0x20, 0x69, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f,
    0x6e, 0x2e, 0x20, 0x49, 0x74, 0x20, 0x69, 0x6e, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x73, 0x20,
    0x74, 0x68, 0x61, 0x74, 0x0a, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e,
    0x74, 0x20, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e,
    0x20, 0x68, 0x61, 0x73, 0x20, 0x62, 0x65, 0x65, 0x6e, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65,
    0x64, 0x20, 0x62, 0x79, 0x20, 0x61, 0x20, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x20, 0x6f, 0x70,
    0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20,
    0x4f, 0x53, 0x4d, 0x20, 0x41, 0x50, 0x49, 0x2e, 0x0a, 0x20, 0x57, 0x68, 0x65, 0x6e, 0x20, 0x61,
    0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x72, 0x20, 0x73, 0x65, 0x74, 0x73, 0x20, 0x74, 0x68, 0x69,
    0x73, 0x20, 0x66, 0x6c, 0x61, 0x67, 0x2c, 0x20, 0x69, 0x74, 0x20, 0x4d, 0x55, 0x53, 0x54, 0x20,
    0x61, 0x64, 0x64, 0x20, 0x61, 0x20, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x5f, 0x66,
    0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x20, 0x74, 0x61, 0x67, 0x20, 0x77, 0x69, 0x74, 0x68,
    0x0a, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x20, 0x22, 0x48, 0x69, 0x73, 0x74, 0x6f, 0x72, 0x69,
    0x63, 0x61, 0x6c, 0x49, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x20,
    0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x42, 0x6c, 0x6f,
    0x63, 0x6b, 0x2e, 0x0a, 0x20, 0x49, 0x66, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x66, 0x6c, 0x61,
    0x67, 0x20, 0x69, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62,
    0x6c, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x73, 0x6f, 0x6d, 0x65, 0x20, 0x6f, 0x62, 0x6a, 0x65,
    0x63, 0x74, 0x20, 0x69, 0x74, 0x20, 0x4d, 0x55, 0x53, 0x54, 0x20, 0x62, 0x65, 0x20, 0x61, 0x73,
    0x73, 0x75, 0x6d, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x62, 0x65, 0x0a, 0x20, 0x74, 0x72, 0x75,
    0x65, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x20, 0x68, 0x61,
    0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x5f, 0x66,
    0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x20, 0x74, 0x61, 0x67, 0x20, 0x22, 0x48, 0x69, 0x73,
    0x74, 0x6f, 0x72, 0x69, 0x63, 0x61, 0x6c, 0x49, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69,
    0x6f, 0x6e, 0x22, 0x0a, 0x20, 0x73, 0x65, 0x74, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06,
    0x02, 0x05, 0x04, 0x12, 0x04, 0xa9, 0x01, 0x03, 0x0b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02,
    0x05, 0x05, 0x12, 0x04, 0xa9, 0x01, 0x0c, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x05,
    0x01, 0x12, 0x04, 0xa9, 0x01, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x05, 0x03,
    0x12, 0x04, 0xa9, 0x01, 0x1b, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x05, 0x08, 0x12,
    0x04, 0xa9, 0x01, 0x1d, 0x2c, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x06, 0x02, 0x05, 0x08, 0xe7, 0x07,
    0x00, 0x12, 0x04, 0xa9, 0x01, 0x1e, 0x2b, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x06, 0x02, 0x05, 0x08,
    0xe7, 0x07, 0x00, 0x02, 0x12, 0x04, 0xa9, 0x01, 0x1e, 0x24, 0x0a, 0x12, 0x0a, 0x0a, 0x04, 0x06,
    0x02, 0x05, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x12, 0x04, 0xa9, 0x01, 0x1e, 0x24, 0x0a, 0x13,
    0x0a, 0x0b, 0x04, 0x06, 0x02, 0x05, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa9,
    0x01, 0x1e, 0x24, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x06, 0x02, 0x05, 0x08, 0xe7, 0x07, 0x00, 0x03,
    0x12, 0x04, 0xa9, 0x01, 0x27, 0x2b, 0x0a, 0x5e, 0x0a, 0x02, 0x04, 0x07, 0x12, 0x06, 0xaf, 0x01,
    0x00, 0xbc, 0x01, 0x01, 0x1a, 0x50, 0x20, 0x54, 0x48, 0x49, 0x53, 0x20, 0x49, 0x53, 0x20, 0x53,
    0x54, 0x55, 0x42, 0x20, 0x44, 0x45, 0x53, 0x49, 0x47, 0x4e, 0x20, 0x46, 0x4f, 0x52, 0x20, 0x43,
    0x48, 0x41, 0x4e, 0x47, 0x45, 0x53, 0x45, 0x54, 0x53, 0x2e, 0x20, 0x4e, 0x4f, 0x54, 0x20, 0x55,
    0x53, 0x45, 0x44, 0x20, 0x52, 0x49, 0x47, 0x48, 0x54, 0x20, 0x4e, 0x4f, 0x57, 0x2e, 0x0a, 0x20,
    0x54, 0x4f, 0x44, 0x4f, 0x3a, 0x20, 0x20, 0x20, 0x20, 0x52, 0x45, 0x4d, 0x4f, 0x56, 0x45, 0x20,
    0x54, 0x48, 0x49, 0x53, 0x3f, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x07, 0x01, 0x12, 0x04, 0xaf,
    0x01, 0x08, 0x11, 0x0a, 0xbe, 0x01, 0x0a, 0x04, 0x04, 0x07, 0x02, 0x00, 0x12, 0x04, 0xb0, 0x01,
    0x03, 0x19, 0x22, 0xaf, 0x01, 0x20, 0x20, 0x20, 0x0a, 0x20, 0x20, 0x20, 0x2f, 0x2f, 0x20, 0x50,
    0x61, 0x72, 0x61, 0x6c, 0x6c, 0x65, 0x6c, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x73, 0x2e, 0x0a,
    0x20, 0x20, 0x20, 0x72, 0x65, 0x70, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20, 0x75, 0x69, 0x6e, 0x74,
    0x33, 0x32, 0x20, 0x6b, 0x65, 0x79, 0x73, 0x20, 0x3d, 0x20, 0x32, 0x20, 0x5b, 0x70, 0x61, 0x63,
    0x6b, 0x65, 0x64, 0x20, 0x3d, 0x20, 0x74, 0x72, 0x75, 0x65, 0x5d, 0x3b, 0x20, 0x2f, 0x2f, 0x20,
    0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x20, 0x49, 0x44, 0x73, 0x2e, 0x0a, 0x20, 0x20, 0x20, 0x72,
    0x65, 0x70, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20, 0x75, 0x69, 0x6e, 0x74, 0x33, 0x32, 0x20, 0x76,
    0x61, 0x6c, 0x73, 0x20, 0x3d, 0x20, 0x33, 0x20, 0x5b, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x64, 0x20,
    0x3d, 0x20, 0x74, 0x72, 0x75, 0x65, 0x5d, 0x3b, 0x20, 0x2f, 0x2f, 0x20, 0x53, 0x74, 0x72, 0x69,
    0x6e, 0x67, 0x20, 0x49, 0x44, 0x73, 0x2e, 0x0a, 0x0a, 0x20, 0x20, 0x20, 0x6f, 0x70, 0x74, 0x69,
    0x6f, 0x6e, 0x61, 0x6c, 0x20, 0x49, 0x6e, 0x66, 0x6f, 0x20, 0x69, 0x6e, 0x66, 0x6f, 0x20, 0x3d,
    0x20, 0x34, 0x3b, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x00, 0x04, 0x12, 0x04, 0xb0,
    0x01, 0x03, 0x0b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x00, 0x05, 0x12, 0x04, 0xb0, 0x01,
    0x0c, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x00, 0x01, 0x12, 0x04, 0xb0, 0x01, 0x12,
    0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x00, 0x03, 0x12, 0x04, 0xb0, 0x01, 0x17, 0x18,
    0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x08, 0x12, 0x06, 0xbf, 0x01, 0x00, 0xc9, 0x01, 0x01, 0x0a, 0x0b,
    0x0a, 0x03, 0x04, 0x08, 0x01, 0x12, 0x04, 0xbf, 0x01, 0x08, 0x0c, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x08, 0x02, 0x00, 0x12, 0x04, 0xc0, 0x01, 0x03, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02,
    0x00, 0x04, 0x12, 0x04, 0xc0, 0x01, 0x03, 0x0b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x00,
    0x05, 0x12, 0x04, 0xc0, 0x01, 0x0c, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x00, 0x01,
    0x12, 0x04, 0xc0, 0x01, 0x13, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x00, 0x03, 0x12,
    0x04, 0xc0, 0x01, 0x18, 0x19, 0x0a, 0x2f, 0x0a, 0x04, 0x04, 0x08, 0x02, 0x01, 0x12, 0x04, 0xc2,
    0x01, 0x03, 0x2c, 0x1a, 0x12, 0x20, 0x50, 0x61, 0x72, 0x61, 0x6c, 0x6c, 0x65, 0x6c, 0x20, 0x61,
    0x72, 0x72, 0x61, 0x79, 0x73, 0x2e, 0x0a, 0x22, 0x0d, 0x20, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67,
    0x20, 0x49, 0x44, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x01, 0x04, 0x12,
    0x04, 0xc2, 0x01, 0x03, 0x0b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x01, 0x05, 0x12, 0x04,
    0xc2, 0x01, 0x0c, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x01, 0x01, 0x12, 0x04, 0xc2,
    0x01, 0x13, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x01, 0x03, 0x12, 0x04, 0xc2, 0x01,
    0x1a, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x01, 0x08, 0x12, 0x04, 0xc2, 0x01, 0x1c,
    0x2b, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x08, 0x02, 0x01, 0x08, 0xe7, 0x07, 0x00, 0x12, 0x04, 0xc2,
    0x01, 0x1d, 0x2a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x08, 0x02, 0x01, 0x08, 0xe7, 0x07, 0x00, 0x02,
    0x12, 0x04, 0xc2, 0x01, 0x1d, 0x23, 0x0a, 0x12, 0x0a, 0x0a, 0x04, 0x08, 0x02, 0x01, 0x08, 0xe7,
    0x07, 0x00, 0x02, 0x00, 0x12, 0x04, 0xc2, 0x01, 0x1d, 0x23, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x08,
    0x02, 0x01, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc2, 0x01, 0x1d, 0x23, 0x0a,
    0x11, 0x0a, 0x09, 0x04, 0x08, 0x02, 0x01, 0x08, 0xe7, 0x07, 0x00, 0x03, 0x12, 0x04, 0xc2, 0x01,
    0x26, 0x2a, 0x0a, 0x1b, 0x0a, 0x04, 0x04, 0x08, 0x02, 0x02, 0x12, 0x04, 0xc3, 0x01, 0x03, 0x2c,
    0x22, 0x0d, 0x20, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x20, 0x49, 0x44, 0x73, 0x2e, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x02, 0x04, 0x12, 0x04, 0xc3, 0x01, 0x03, 0x0b, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x08, 0x02, 0x02, 0x05, 0x12, 0x04, 0xc3, 0x01, 0x0c, 0x12, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x08, 0x02, 0x02, 0x01, 0x12, 0x04, 0xc3, 0x01, 0x13, 0x17, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x08, 0x02, 0x02, 0x03, 0x12, 0x04, 0xc3, 0x01, 0x1a, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x08, 0x02, 0x02, 0x08, 0x12, 0x04, 0xc3, 0x01, 0x1c, 0x2b, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x08,
    0x02, 0x02, 0x08, 0xe7, 0x07, 0x00, 0x12, 0x04, 0xc3, 0x01, 0x1d, 0x2a, 0x0a, 0x11, 0x0a, 0x09,
    0x04, 0x08, 0x02, 0x02, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x12, 0x04, 0xc3, 0x01, 0x1d, 0x23, 0x0a,
    0x12, 0x0a, 0x0a, 0x04, 0x08, 0x02, 0x02, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x12, 0x04, 0xc3,
    0x01, 0x1d, 0x23, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x08, 0x02, 0x02, 0x08, 0xe7, 0x07, 0x00, 0x02,
    0x00, 0x01, 0x12, 0x04, 0xc3, 0x01, 0x1d, 0x23, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x08, 0x02, 0x02,
    0x08, 0xe7, 0x07, 0x00, 0x03, 0x12, 0x04, 0xc3, 0x01, 0x26, 0x2a, 0x0a, 0x2a, 0x0a, 0x04, 0x04,
    0x08, 0x02, 0x03, 0x12, 0x04, 0xc5, 0x01, 0x03, 0x1a, 0x22, 0x1c, 0x20, 0x4d, 0x61, 0x79, 0x20,
    0x62, 0x65, 0x20, 0x6f, 0x6d, 0x69, 0x74, 0x74, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x6f, 0x6d,
    0x69, 0x74, 0x6d, 0x65, 0x74, 0x61, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x03, 0x04,
    0x12, 0x04, 0xc5, 0x01, 0x03, 0x0b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x03, 0x06, 0x12,
    0x04, 0xc5, 0x01, 0x0c, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x03, 0x01, 0x12, 0x04,
    0xc5, 0x01, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x03, 0x03, 0x12, 0x04, 0xc5,
    0x01, 0x18, 0x19, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x08, 0x02, 0x04, 0x12, 0x04, 0xc7, 0x01, 0x03,
    0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x04, 0x04, 0x12, 0x04, 0xc7, 0x01, 0x03, 0x0b,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x04, 0x05, 0x12, 0x04, 0xc7, 0x01, 0x0c, 0x12, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x04, 0x01, 0x12, 0x04, 0xc7, 0x01, 0x13, 0x16, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x08, 0x02, 0x04, 0x03, 0x12, 0x04, 0xc7, 0x01, 0x19, 0x1a, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x08, 0x02, 0x05, 0x12, 0x04, 0xc8, 0x01, 0x03, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x08, 0x02, 0x05, 0x04, 0x12, 0x04, 0xc8, 0x01, 0x03, 0x0b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08,
    0x02, 0x05, 0x05, 0x12, 0x04, 0xc8, 0x01, 0x0c, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02,
    0x05, 0x01, 0x12, 0x04, 0xc8, 0x01, 0x13, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x05,
    0x03, 0x12, 0x04, 0xc8, 0x01, 0x19, 0x1a, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x09, 0x12, 0x06, 0xd7,
    0x01, 0x00, 0xe2, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x09, 0x01, 0x12, 0x04, 0xd7, 0x01,
    0x08, 0x12, 0x0a, 0x1b, 0x0a, 0x04, 0x04, 0x09, 0x02, 0x00, 0x12, 0x04, 0xd8, 0x01, 0x03, 0x2a,
    0x22, 0x0d, 0x20, 0x44, 0x45, 0x4c, 0x54, 0x41, 0x20, 0x63, 0x6f, 0x64, 0x65, 0x64, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x00, 0x04, 0x12, 0x04, 0xd8, 0x01, 0x03, 0x0b, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x09, 0x02, 0x00, 0x05, 0x12, 0x04, 0xd8, 0x01, 0x0c, 0x12, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x09, 0x02, 0x00, 0x01, 0x12, 0x04, 0xd8, 0x01, 0x13, 0x15, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x09, 0x02, 0x00, 0x03, 0x12, 0x04, 0xd8, 0x01, 0x18, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x09, 0x02, 0x00, 0x08, 0x12, 0x04, 0xd8, 0x01, 0x1a, 0x29, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x09,
    0x02, 0x00, 0x08, 0xe7, 0x07, 0x00, 0x12, 0x04, 0xd8, 0x01, 0x1b, 0x28, 0x0a, 0x11, 0x0a, 0x09,
    0x04, 0x09, 0x02, 0x00, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x12, 0x04, 0xd8, 0x01, 0x1b, 0x21, 0x0a,
    0x12, 0x0a, 0x0a, 0x04, 0x09, 0x02, 0x00, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x12, 0x04, 0xd8,
    0x01, 0x1b, 0x21, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x09, 0x02, 0x00, 0x08, 0xe7, 0x07, 0x00, 0x02,
    0x00, 0x01, 0x12, 0x04, 0xd8, 0x01, 0x1b, 0x21, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x09, 0x02, 0x00,
    0x08, 0xe7, 0x07, 0x00, 0x03, 0x12, 0x04, 0xd8, 0x01, 0x24, 0x28, 0x0a, 0x26, 0x0a, 0x04, 0x04,
    0x09, 0x02, 0x01, 0x12, 0x04, 0xdb, 0x01, 0x03, 0x24, 0x1a, 0x18, 0x72, 0x65, 0x70, 0x65, 0x61,
    0x74, 0x65, 0x64, 0x20, 0x49, 0x6e, 0x66, 0x6f, 0x20, 0x69, 0x6e, 0x66, 0x6f, 0x20, 0x3d, 0x20,
    0x34, 0x3b, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x01, 0x04, 0x12, 0x04, 0xdb, 0x01,
    0x03, 0x0b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x01, 0x06, 0x12, 0x04, 0xdb, 0x01, 0x0c,
    0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x01, 0x01, 0x12, 0x04, 0xdb, 0x01, 0x16, 0x1f,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x01, 0x03, 0x12, 0x04, 0xdb, 0x01, 0x22, 0x23, 0x0a,
    0x1b, 0x0a, 0x04, 0x04, 0x09, 0x02, 0x02, 0x12, 0x04, 0xdd, 0x01, 0x03, 0x2b, 0x22, 0x0d, 0x20,
    0x44, 0x45, 0x4c, 0x54, 0x41, 0x20, 0x63, 0x6f, 0x64, 0x65, 0x64, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x09, 0x02, 0x02, 0x04, 0x12, 0x04, 0xdd, 0x01, 0x03, 0x0b, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x09, 0x02, 0x02, 0x05, 0x12, 0x04, 0xdd, 0x01, 0x0c, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09,
    0x02, 0x02, 0x01, 0x12, 0x04, 0xdd, 0x01, 0x13, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02,
    0x02, 0x03, 0x12, 0x04, 0xdd, 0x01, 0x19, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x02,
    0x08, 0x12, 0x04, 0xdd, 0x01, 0x1b, 0x2a, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x09, 0x02, 0x02, 0x08,
    0xe7, 0x07, 0x00, 0x12, 0x04, 0xdd, 0x01, 0x1c, 0x29, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x09, 0x02,
    0x02, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x12, 0x04, 0xdd, 0x01, 0x1c, 0x22, 0x0a, 0x12, 0x0a, 0x0a,
    0x04, 0x09, 0x02, 0x02, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x12, 0x04, 0xdd, 0x01, 0x1c, 0x22,
    0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x09, 0x02, 0x02, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xdd, 0x01, 0x1c, 0x22, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x09, 0x02, 0x02, 0x08, 0xe7, 0x07,
    0x00, 0x03, 0x12, 0x04, 0xdd, 0x01, 0x25, 0x29, 0x0a, 0x1b, 0x0a, 0x04, 0x04, 0x09, 0x02, 0x03,
    0x12, 0x04, 0xde, 0x01, 0x03, 0x2b, 0x22, 0x0d, 0x20, 0x44, 0x45, 0x4c, 0x54, 0x41, 0x20, 0x63,
    0x6f, 0x64, 0x65, 0x64, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x03, 0x04, 0x12, 0x04,
    0xde, 0x01, 0x03, 0x0b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x03, 0x05, 0x12, 0x04, 0xde,
    0x01, 0x0c, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x03, 0x01, 0x12, 0x04, 0xde, 0x01,
    0x13, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x03, 0x03, 0x12, 0x04, 0xde, 0x01, 0x19,
    0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x03, 0x08, 0x12, 0x04, 0xde, 0x01, 0x1b, 0x2a,
    0x0a, 0x10, 0x0a, 0x08, 0x04, 0x09, 0x02, 0x03, 0x08, 0xe7, 0x07, 0x00, 0x12, 0x04, 0xde, 0x01,
    0x1c, 0x29, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x09, 0x02, 0x03, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x12,
    0x04, 0xde, 0x01, 0x1c, 0x22, 0x0a, 0x12, 0x0a, 0x0a, 0x04, 0x09, 0x02, 0x03, 0x08, 0xe7, 0x07,
    0x00, 0x02, 0x00, 0x12, 0x04, 0xde, 0x01, 0x1c, 0x22, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x09, 0x02,
    0x03, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xde, 0x01, 0x1c, 0x22, 0x0a, 0x11,
    0x0a, 0x09, 0x04, 0x09, 0x02, 0x03, 0x08, 0xe7, 0x07, 0x00, 0x03, 0x12, 0x04, 0xde, 0x01, 0x25,
    0x29, 0x0a, 0x75, 0x0a, 0x04, 0x04, 0x09, 0x02, 0x04, 0x12, 0x04, 0xe1, 0x01, 0x03, 0x31, 0x1a,
    0x67, 0x20, 0x53, 0x70, 0x65, 0x63, 0x69, 0x61, 0x6c, 0x20, 0x70, 0x61, 0x63, 0x6b, 0x69, 0x6e,
    0x67, 0x20, 0x6f, 0x66, 0x20, 0x6b, 0x65, 0x79, 0x73, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x76, 0x61,
    0x6c, 0x73, 0x20, 0x69, 0x6e, 0x74, 0x6f, 0x20, 0x6f, 0x6e, 0x65, 0x20, 0x61, 0x72, 0x72, 0x61,
    0x79, 0x2e, 0x20, 0x4d, 0x61, 0x79, 0x20, 0x62, 0x65, 0x20, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x20,
    0x69, 0x66, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x6e, 0x6f, 0x64, 0x65, 0x73, 0x20, 0x69, 0x6e, 0x20,
    0x74, 0x68, 0x69, 0x73, 0x20, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x20, 0x61, 0x72, 0x65, 0x20, 0x74,
    0x61, 0x67, 0x6c, 0x65, 0x73, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x04,
    0x04, 0x12, 0x04, 0xe1, 0x01, 0x03, 0x0b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x04, 0x05,
    0x12, 0x04, 0xe1, 0x01, 0x0c, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x04, 0x01, 0x12,
    0x04, 0xe1, 0x01, 0x12, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x04, 0x03, 0x12, 0x04,
    0xe1, 0x01, 0x1e, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x04, 0x08, 0x12, 0x04, 0xe1,
    0x01, 0x21, 0x30, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x09, 0x02, 0x04, 0x08, 0xe7, 0x07, 0x00, 0x12,
    0x04, 0xe1, 0x01, 0x22, 0x2f, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x09, 0x02, 0x04, 0x08, 0xe7, 0x07,
    0x00, 0x02, 0x12, 0x04, 0xe1, 0x01, 0x22, 0x28, 0x0a, 0x12, 0x0a, 0x0a, 0x04, 0x09, 0x02, 0x04,
    0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x12, 0x04, 0xe1, 0x01, 0x22, 0x28, 0x0a, 0x13, 0x0a, 0x0b,
    0x04, 0x09, 0x02, 0x04, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xe1, 0x01, 0x22,
    0x28, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x09, 0x02, 0x04, 0x08, 0xe7, 0x07, 0x00, 0x03, 0x12, 0x04,
    0xe1, 0x01, 0x2b, 0x2f, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x0a, 0x12, 0x06, 0xe5, 0x01, 0x00, 0xee,
    0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x0a, 0x01, 0x12, 0x04, 0xe5, 0x01, 0x08, 0x0b, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x0a, 0x02, 0x00, 0x12, 0x04, 0xe6, 0x01, 0x03, 0x19, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0a, 0x02, 0x00, 0x04, 0x12, 0x04, 0xe6, 0x01, 0x03, 0x0b, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0a, 0x02, 0x00, 0x05, 0x12, 0x04, 0xe6, 0x01, 0x0c, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0a, 0x02, 0x00, 0x01, 0x12, 0x04, 0xe6, 0x01, 0x12, 0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a,
    0x02, 0x00, 0x03, 0x12, 0x04, 0xe6, 0x01, 0x17, 0x18, 0x0a, 0x20, 0x0a, 0x04, 0x04, 0x0a, 0x02,
    0x01, 0x12, 0x04, 0xe8, 0x01, 0x03, 0x2c, 0x1a, 0x12, 0x20, 0x50, 0x61, 0x72, 0x61, 0x6c, 0x6c,
    0x65, 0x6c, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0a, 0x02, 0x01, 0x04, 0x12, 0x04, 0xe8, 0x01, 0x03, 0x0b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a,
    0x02, 0x01, 0x05, 0x12, 0x04, 0xe8, 0x01, 0x0c, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02,
    0x01, 0x01, 0x12, 0x04, 0xe8, 0x01, 0x13, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x01,
    0x03, 0x12, 0x04, 0xe8, 0x01, 0x1a, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x01, 0x08,
    0x12, 0x04, 0xe8, 0x01, 0x1c, 0x2b, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x0a, 0x02, 0x01, 0x08, 0xe7,
    0x07, 0x00, 0x12, 0x04, 0xe8, 0x01, 0x1d, 0x2a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x0a, 0x02, 0x01,
    0x08, 0xe7, 0x07, 0x00, 0x02, 0x12, 0x04, 0xe8, 0x01, 0x1d, 0x23, 0x0a, 0x12, 0x0a, 0x0a, 0x04,
    0x0a, 0x02, 0x01, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x12, 0x04, 0xe8, 0x01, 0x1d, 0x23, 0x0a,
    0x13, 0x0a, 0x0b, 0x04, 0x0a, 0x02, 0x01, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04,
    0xe8, 0x01, 0x1d, 0x23, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x0a, 0x02, 0x01, 0x08, 0xe7, 0x07, 0x00,
    0x03, 0x12, 0x04, 0xe8, 0x01, 0x26, 0x2a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0a, 0x02, 0x02, 0x12,
    0x04, 0xe9, 0x01, 0x03, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x02, 0x04, 0x12, 0x04,
    0xe9, 0x01, 0x03, 0x0b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x02, 0x05, 0x12, 0x04, 0xe9,
    0x01, 0x0c, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x02, 0x01, 0x12, 0x04, 0xe9, 0x01,
    0x13, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x02, 0x03, 0x12, 0x04, 0xe9, 0x01, 0x1a,
    0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x02, 0x08, 0x12, 0x04, 0xe9, 0x01, 0x1c, 0x2b,
    0x0a, 0x10, 0x0a, 0x08, 0x04, 0x0a, 0x02, 0x02, 0x08, 0xe7, 0x07, 0x00, 0x12, 0x04, 0xe9, 0x01,
    0x1d, 0x2a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x0a, 0x02, 0x02, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x12,
    0x04, 0xe9, 0x01, 0x1d, 0x23, 0x0a, 0x12, 0x0a, 0x0a, 0x04, 0x0a, 0x02, 0x02, 0x08, 0xe7, 0x07,
    0x00, 0x02, 0x00, 0x12, 0x04, 0xe9, 0x01, 0x1d, 0x23, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x0a, 0x02,
    0x02, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xe9, 0x01, 0x1d, 0x23, 0x0a, 0x11,
    0x0a, 0x09, 0x04, 0x0a, 0x02, 0x02, 0x08, 0xe7, 0x07, 0x00, 0x03, 0x12, 0x04, 0xe9, 0x01, 0x26,
    0x2a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0a, 0x02, 0x03, 0x12, 0x04, 0xeb, 0x01, 0x03, 0x1a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x03, 0x04, 0x12, 0x04, 0xeb, 0x01, 0x03, 0x0b, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0a, 0x02, 0x03, 0x06, 0x12, 0x04, 0xeb, 0x01, 0x0c, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0a, 0x02, 0x03, 0x01, 0x12, 0x04, 0xeb, 0x01, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0a, 0x02, 0x03, 0x03, 0x12, 0x04, 0xeb, 0x01, 0x18, 0x19, 0x0a, 0x1b, 0x0a, 0x04, 0x04,
    0x0a, 0x02, 0x04, 0x12, 0x04, 0xed, 0x01, 0x03, 0x2c, 0x22, 0x0d, 0x20, 0x44, 0x45, 0x4c, 0x54,
    0x41, 0x20, 0x63, 0x6f, 0x64, 0x65, 0x64, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x04,
    0x04, 0x12, 0x04, 0xed, 0x01, 0x03, 0x0b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x04, 0x05,
    0x12, 0x04, 0xed, 0x01, 0x0c, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x04, 0x01, 0x12,
    0x04, 0xed, 0x01, 0x13, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x04, 0x03, 0x12, 0x04,
    0xed, 0x01, 0x1a, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x04, 0x08, 0x12, 0x04, 0xed,
    0x01, 0x1c, 0x2b, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x0a, 0x02, 0x04, 0x08, 0xe7, 0x07, 0x00, 0x12,
    0x04, 0xed, 0x01, 0x1d, 0x2a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x0a, 0x02, 0x04, 0x08, 0xe7, 0x07,
    0x00, 0x02, 0x12, 0x04, 0xed, 0x01, 0x1d, 0x23, 0x0a, 0x12, 0x0a, 0x0a, 0x04, 0x0a, 0x02, 0x04,
    0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x12, 0x04, 0xed, 0x01, 0x1d, 0x23, 0x0a, 0x13, 0x0a, 0x0b,
    0x04, 0x0a, 0x02, 0x04, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xed, 0x01, 0x1d,
    0x23, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x0a, 0x02, 0x04, 0x08, 0xe7, 0x07, 0x00, 0x03, 0x12, 0x04,
    0xed, 0x01, 0x26, 0x2a, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x0b, 0x12, 0x06, 0xf0, 0x01, 0x00, 0x82,
    0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x0b, 0x01, 0x12, 0x04, 0xf0, 0x01, 0x08, 0x10, 0x0a,
    0x0e, 0x0a, 0x04, 0x04, 0x0b, 0x04, 0x00, 0x12, 0x06, 0xf1, 0x01, 0x02, 0xf5, 0x01, 0x03, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x04, 0x00, 0x01, 0x12, 0x04, 0xf1, 0x01, 0x07, 0x11, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x0b, 0x04, 0x00, 0x02, 0x00, 0x12, 0x04, 0xf2, 0x01, 0x04, 0x0d, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x0b, 0x04, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xf2, 0x01, 0x04, 0x08, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x0b, 0x04, 0x00, 0x02, 0x00, 0x02, 0x12, 0x04, 0xf2, 0x01, 0x0b, 0x0c,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x0b, 0x04, 0x00, 0x02, 0x01, 0x12, 0x04, 0xf3, 0x01, 0x04, 0x0c,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0b, 0x04, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xf3, 0x01, 0x04,
    0x07, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0b, 0x04, 0x00, 0x02, 0x01, 0x02, 0x12, 0x04, 0xf3, 0x01,
    0x0a, 0x0b, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x0b, 0x04, 0x00, 0x02, 0x02, 0x12, 0x04, 0xf4, 0x01,
    0x04, 0x11, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0b, 0x04, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xf4,
    0x01, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0b, 0x04, 0x00, 0x02, 0x02, 0x02, 0x12, 0x04,
    0xf4, 0x01, 0x0f, 0x10, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0b, 0x02, 0x00, 0x12, 0x04, 0xf6, 0x01,
    0x03, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x00, 0x04, 0x12, 0x04, 0xf6, 0x01, 0x03,
    0x0b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x00, 0x05, 0x12, 0x04, 0xf6, 0x01, 0x0c, 0x11,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x00, 0x01, 0x12, 0x04, 0xf6, 0x01, 0x12, 0x14, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x00, 0x03, 0x12, 0x04, 0xf6, 0x01, 0x17, 0x18, 0x0a, 0x20,
    0x0a, 0x04, 0x04, 0x0b, 0x02, 0x01, 0x12, 0x04, 0xf9, 0x01, 0x03, 0x2c, 0x1a, 0x12, 0x20, 0x50,
    0x61, 0x72, 0x61, 0x6c, 0x6c, 0x65, 0x6c, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x73, 0x2e, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x01, 0x04, 0x12, 0x04, 0xf9, 0x01, 0x03, 0x0b, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x01, 0x05, 0x12, 0x04, 0xf9, 0x01, 0x0c, 0x12, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0b, 0x02, 0x01, 0x01, 0x12, 0x04, 0xf9, 0x01, 0x13, 0x17, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0b, 0x02, 0x01, 0x03, 0x12, 0x04, 0xf9, 0x01, 0x1a, 0x1b, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0b, 0x02, 0x01, 0x08, 0x12, 0x04, 0xf9, 0x01, 0x1c, 0x2b, 0x0a, 0x10, 0x0a, 0x08, 0x04,
    0x0b, 0x02, 0x01, 0x08, 0xe7, 0x07, 0x00, 0x12, 0x04, 0xf9, 0x01, 0x1d, 0x2a, 0x0a, 0x11, 0x0a,
    0x09, 0x04, 0x0b, 0x02, 0x01, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x12, 0x04, 0xf9, 0x01, 0x1d, 0x23,
    0x0a, 0x12, 0x0a, 0x0a, 0x04, 0x0b, 0x02, 0x01, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x12, 0x04,
    0xf9, 0x01, 0x1d, 0x23, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x0b, 0x02, 0x01, 0x08, 0xe7, 0x07, 0x00,
    0x02, 0x00, 0x01, 0x12, 0x04, 0xf9, 0x01, 0x1d, 0x23, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x0b, 0x02,
    0x01, 0x08, 0xe7, 0x07, 0x00, 0x03, 0x12, 0x04, 0xf9, 0x01, 0x26, 0x2a, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x0b, 0x02, 0x02, 0x12, 0x04, 0xfa, 0x01, 0x03, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b,
    0x02, 0x02, 0x04, 0x12, 0x04, 0xfa, 0x01, 0x03, 0x0b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02,
    0x02, 0x05, 0x12, 0x04, 0xfa, 0x01, 0x0c, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x02,
    0x01, 0x12, 0x04, 0xfa, 0x01, 0x13, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x02, 0x03,
    0x12, 0x04, 0xfa, 0x01, 0x1a, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x02, 0x08, 0x12,
    0x04, 0xfa, 0x01, 0x1c, 0x2b, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x0b, 0x02, 0x02, 0x08, 0xe7, 0x07,
    0x00, 0x12, 0x04, 0xfa, 0x01, 0x1d, 0x2a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x0b, 0x02, 0x02, 0x08,
    0xe7, 0x07, 0x00, 0x02, 0x12, 0x04, 0xfa, 0x01, 0x1d, 0x23, 0x0a, 0x12, 0x0a, 0x0a, 0x04, 0x0b,
    0x02, 0x02, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x12, 0x04, 0xfa, 0x01, 0x1d, 0x23, 0x0a, 0x13,
    0x0a, 0x0b, 0x04, 0x0b, 0x02, 0x02, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xfa,
    0x01, 0x1d, 0x23, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x0b, 0x02, 0x02, 0x08, 0xe7, 0x07, 0x00, 0x03,
    0x12, 0x04, 0xfa, 0x01, 0x26, 0x2a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0b, 0x02, 0x03, 0x12, 0x04,
    0xfc, 0x01, 0x03, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x03, 0x04, 0x12, 0x04, 0xfc,
    0x01, 0x03, 0x0b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x03, 0x06, 0x12, 0x04, 0xfc, 0x01,
    0x0c, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x03, 0x01, 0x12, 0x04, 0xfc, 0x01, 0x11,
    0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x03, 0x03, 0x12, 0x04, 0xfc, 0x01, 0x18, 0x19,
    0x0a, 0x1f, 0x0a, 0x04, 0x04, 0x0b, 0x02, 0x04, 0x12, 0x04, 0xff, 0x01, 0x03, 0x30, 0x1a, 0x11,
    0x20, 0x50, 0x61, 0x72, 0x61, 0x6c, 0x6c, 0x65, 0x6c, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x73,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x04, 0x04, 0x12, 0x04, 0xff, 0x01, 0x03, 0x0b,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x04, 0x05, 0x12, 0x04, 0xff, 0x01, 0x0c, 0x11, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x04, 0x01, 0x12, 0x04, 0xff, 0x01, 0x12, 0x1b, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0b, 0x02, 0x04, 0x03, 0x12, 0x04, 0xff, 0x01, 0x1e, 0x1f, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0b, 0x02, 0x04, 0x08, 0x12, 0x04, 0xff, 0x01, 0x20, 0x2f, 0x0a, 0x10, 0x0a, 0x08,
    0x04, 0x0b, 0x02, 0x04, 0x08, 0xe7, 0x07, 0x00, 0x12, 0x04, 0xff, 0x01, 0x21, 0x2e, 0x0a, 0x11,
    0x0a, 0x09, 0x04, 0x0b, 0x02, 0x04, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x12, 0x04, 0xff, 0x01, 0x21,
    0x27, 0x0a, 0x12, 0x0a, 0x0a, 0x04, 0x0b, 0x02, 0x04, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x12,
    0x04, 0xff, 0x01, 0x21, 0x27, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x0b, 0x02, 0x04, 0x08, 0xe7, 0x07,
    0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xff, 0x01, 0x21, 0x27, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x0b,
    0x02, 0x04, 0x08, 0xe7, 0x07, 0x00, 0x03, 0x12, 0x04, 0xff, 0x01, 0x2a, 0x2e, 0x0a, 0x1d, 0x0a,
    0x04, 0x04, 0x0b, 0x02, 0x05, 0x12, 0x04, 0x80, 0x02, 0x03, 0x2e, 0x22, 0x0f, 0x20, 0x44, 0x45,
    0x4c, 0x54, 0x41, 0x20, 0x65, 0x6e, 0x63, 0x6f, 0x64, 0x65, 0x64, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0b, 0x02, 0x05, 0x04, 0x12, 0x04, 0x80, 0x02, 0x03, 0x0b, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0b, 0x02, 0x05, 0x05, 0x12, 0x04, 0x80, 0x02, 0x0c, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b,
    0x02, 0x05, 0x01, 0x12, 0x04, 0x80, 0x02, 0x13, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02,
    0x05, 0x03, 0x12, 0x04, 0x80, 0x02, 0x1c, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x05,
    0x08, 0x12, 0x04, 0x80, 0x02, 0x1e, 0x2d, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x0b, 0x02, 0x05, 0x08,
    0xe7, 0x07, 0x00, 0x12, 0x04, 0x80, 0x02, 0x1f, 0x2c, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x0b, 0x02,
    0x05, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x12, 0x04, 0x80, 0x02, 0x1f, 0x25, 0x0a, 0x12, 0x0a, 0x0a,
    0x04, 0x0b, 0x02, 0x05, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x12, 0x04, 0x80, 0x02, 0x1f, 0x25,
    0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x0b, 0x02, 0x05, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x01, 0x12,
    0x04, 0x80, 0x02, 0x1f, 0x25, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x0b, 0x02, 0x05, 0x08, 0xe7, 0x07,
    0x00, 0x03, 0x12, 0x04, 0x80, 0x02, 0x28, 0x2c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0b, 0x02, 0x06,
    0x12, 0x04, 0x81, 0x02, 0x03, 0x32, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x06, 0x04, 0x12,
    0x04, 0x81, 0x02, 0x03, 0x0b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x06, 0x06, 0x12, 0x04,
    0x81, 0x02, 0x0c, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x06, 0x01, 0x12, 0x04, 0x81,
    0x02, 0x17, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x06, 0x03, 0x12, 0x04, 0x81, 0x02,
    0x1f, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x06, 0x08, 0x12, 0x04, 0x81, 0x02, 0x22,
    0x31, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x0b, 0x02, 0x06, 0x08, 0xe7, 0x07, 0x00, 0x12, 0x04, 0x81,
    0x02, 0x23, 0x30, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x0b, 0x02, 0x06, 0x08, 0xe7, 0x07, 0x00, 0x02,
    0x12, 0x04, 0x81, 0x02, 0x23, 0x29, 0x0a, 0x12, 0x0a, 0x0a, 0x04, 0x0b, 0x02, 0x06, 0x08, 0xe7,
    0x07, 0x00, 0x02, 0x00, 0x12, 0x04, 0x81, 0x02, 0x23, 0x29, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x0b,
    0x02, 0x06, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0x81, 0x02, 0x23, 0x29, 0x0a,
    0x11, 0x0a, 0x09, 0x04, 0x0b, 0x02, 0x06, 0x08, 0xe7, 0x07, 0x00, 0x03, 0x12, 0x04, 0x81, 0x02,
    0x2c, 0x30,
];

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy { lock: ::protobuf::lazy::ONCE_INIT, ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto };

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
